<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport"
    content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, interactive-widget=resizes-content">
  <title>Private Chat</title>

  <!-- PWA Meta Tags -->
  <meta name="description" content="Private chat application with audio calls">
  <meta name="theme-color" content="#e94560">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Private Chat">

  <!-- Manifest -->
  <link rel="manifest" href="/manifest.json">

  <!-- Icons -->
  <link rel="icon" type="image/png" sizes="32x32" href="/icon-32.png">
  <link rel="apple-touch-icon" sizes="180x180" href="/icon-180.png">

  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    :root {
      --primary: #e94560;
      --primary-light: #ff6b6b;
      --success: #22c55e;
      --success-light: #4ade80;
      --danger: #ef4444;
      --warning: #f59e0b;
      --info: #3b82f6;
      --bg-dark: #1a1a2e;
      --bg-darker: #16213e;
      --bg-card: #252547;
      --text: #fff;
      --text-muted: #888;
      --border-radius: 12px;
      --transition: 0.2s ease;
    }

    html,
    body {
      height: 100%;
      overflow: hidden;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: linear-gradient(135deg, var(--bg-dark), var(--bg-darker));
      color: var(--text);
      -webkit-tap-highlight-color: transparent;
    }

    /* Connection Status */
    .connection-status {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      padding: 8px;
      text-align: center;
      font-size: 12px;
      font-weight: 500;
      z-index: 1000;
      transition: transform 0.3s ease;
      transform: translateY(-100%);
    }

    .connection-status.show {
      transform: translateY(0);
    }

    .connection-status.connecting {
      background: var(--warning);
      color: #000;
    }

    .connection-status.connected {
      background: var(--success);
      color: #fff;
    }

    .connection-status.disconnected {
      background: var(--danger);
      color: #fff;
    }

    .connection-status.reconnecting {
      background: var(--info);
      color: #fff;
    }

    /* Screens */
    .screen {
      display: none;
      position: fixed;
      inset: 0;
    }

    .screen.active {
      display: flex;
      flex-direction: column;
    }

    /* Join Screen */
    #joinScreen {
      align-items: center;
      justify-content: center;
    }

    .join-box {
      text-align: center;
      padding: 20px;
      width: 100%;
      max-width: 320px;
    }

    .join-box h1 {
      font-size: 3rem;
      margin-bottom: 20px;
    }

    .join-box input {
      width: 100%;
      padding: 15px;
      margin-bottom: 12px;
      border: 2px solid rgba(255, 255, 255, 0.1);
      border-radius: var(--border-radius);
      background: rgba(255, 255, 255, 0.1);
      color: var(--text);
      font-size: 16px;
      transition: border-color var(--transition), background var(--transition);
    }

    .join-box input:focus {
      outline: none;
      border-color: var(--primary);
      background: rgba(255, 255, 255, 0.15);
    }

    .join-box input::placeholder {
      color: var(--text-muted);
    }

    .join-box button {
      width: 100%;
      padding: 15px;
      border: none;
      border-radius: var(--border-radius);
      background: linear-gradient(135deg, var(--primary), var(--primary-light));
      color: var(--text);
      font-size: 16px;
      font-weight: bold;
      cursor: pointer;
      transition: transform var(--transition), opacity var(--transition);
    }

    .join-box button:active {
      transform: scale(0.98);
    }

    .join-box button:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }

    .join-box .error-msg {
      color: var(--danger);
      font-size: 13px;
      margin-top: 10px;
      min-height: 20px;
    }

    /* Chat Screen */
    #chatScreen {
      background: var(--bg-dark);
      height: 100%;
    }

    .chat-header {
      padding: 15px;
      background: rgba(0, 0, 0, 0.5);
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-shrink: 0;
      z-index: 10;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    .chat-header h2 {
      font-size: 16px;
    }

    .chat-header .info {
      color: var(--success-light);
      font-size: 13px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 5px;
    }

    .chat-header .info .status-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--success);
      animation: pulse-dot 2s infinite;
    }

    @keyframes pulse-dot {

      0%,
      100% {
        opacity: 1;
      }

      50% {
        opacity: 0.5;
      }
    }

    .leave-btn {
      background: var(--danger);
      border: none;
      color: var(--text);
      padding: 8px 15px;
      border-radius: 8px;
      cursor: pointer;
      transition: opacity var(--transition);
    }

    .leave-btn:active {
      opacity: 0.8;
    }

    /* Messages container */
    .messages-wrapper {
      flex: 1;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      min-height: 0;
    }

    .messages {
      flex: 1;
      overflow-y: auto;
      overflow-x: hidden;
      padding: 15px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      -webkit-overflow-scrolling: touch;
      overscroll-behavior: contain;
      scroll-behavior: smooth;
    }

    .msg {
      max-width: 80%;
      padding: 10px 14px;
      border-radius: 15px;
      animation: fadeIn 0.2s ease;
      position: relative;
      word-wrap: break-word;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translateY(10px);
      }

      to {
        opacity: 1;
      }
    }

    .msg.mine {
      align-self: flex-end;
      background: linear-gradient(135deg, var(--primary), var(--primary-light));
      border-bottom-right-radius: 4px;
    }

    .msg.other {
      align-self: flex-start;
      background: rgba(255, 255, 255, 0.1);
      border-bottom-left-radius: 4px;
    }

    .msg .sender {
      font-size: 11px;
      color: #ffd700;
      margin-bottom: 4px;
      font-weight: 500;
    }

    .msg .text {
      font-size: 15px;
      word-break: break-word;
      line-height: 1.4;
      color: var(--text);
    }

    .msg .text img {
      max-width: 200px;
      max-height: 200px;
      border-radius: 8px;
      margin-top: 5px;
      cursor: pointer;
      display: block;
    }

    .msg .meta {
      display: flex;
      align-items: center;
      justify-content: flex-end;
      gap: 6px;
      margin-top: 5px;
    }

    .msg .time {
      font-size: 10px;
      color: rgba(255, 255, 255, 0.5);
    }

    .msg .ticks {
      font-size: 12px;
      color: rgba(255, 255, 255, 0.5);
      transition: color 0.3s;
    }

    .msg .ticks.seen {
      color: var(--success-light);
    }

    .msg .ticks.delivered {
      color: rgba(255, 255, 255, 0.7);
    }

    /* Pending/Sending message styles */
    .msg.pending {
      opacity: 0.7;
    }

    .msg .ticks.sending {
      color: rgba(255, 255, 255, 0.4);
      animation: pulse-sending 1s infinite;
    }

    @keyframes pulse-sending {

      0%,
      100% {
        opacity: 0.4;
      }

      50% {
        opacity: 1;
      }
    }

    .msg .ticks.queued {
      color: var(--warning);
      animation: rotate-clock 2s linear infinite;
    }

    @keyframes rotate-clock {
      from {
        transform: rotate(0deg);
      }

      to {
        transform: rotate(360deg);
      }
    }

    .msg .ticks.failed {
      color: var(--danger) !important;
      font-weight: bold;
    }

    .msg.sys {
      align-self: center;
      background: rgba(255, 255, 255, 0.05);
      color: var(--text-muted);
      font-size: 12px;
      padding: 6px 12px;
    }

    /* Message highlight animation */
    @keyframes highlight {

      0%,
      100% {
        background: inherit;
      }

      50% {
        background: rgba(233, 69, 96, 0.3);
      }
    }

    /* Typing Indicator */
    .typing-indicator {
      height: 24px;
      padding: 0 15px;
      font-size: 13px;
      color: var(--text-muted);
      font-style: italic;
      flex-shrink: 0;
      overflow: hidden;
      display: flex;
      align-items: center;
    }

    .typing-indicator:empty::before {
      content: '\00a0';
    }

    .typing-dots {
      display: inline-flex;
      gap: 3px;
      margin-left: 5px;
    }

    .typing-dots span {
      width: 4px;
      height: 4px;
      background: var(--text-muted);
      border-radius: 50%;
      animation: typingBounce 1.4s infinite ease-in-out;
    }

    .typing-dots span:nth-child(1) {
      animation-delay: 0s;
    }

    .typing-dots span:nth-child(2) {
      animation-delay: 0.2s;
    }

    .typing-dots span:nth-child(3) {
      animation-delay: 0.4s;
    }

    @keyframes typingBounce {

      0%,
      60%,
      100% {
        transform: translateY(0);
      }

      30% {
        transform: translateY(-4px);
      }
    }

    /* Chat input */
    .chat-input {
      padding: 10px 12px;
      padding-bottom: max(10px, env(safe-area-inset-bottom));
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      gap: 10px;
      align-items: center;
      flex-shrink: 0;
      z-index: 10;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    .chat-input input {
      flex: 1;
      padding: 12px 16px;
      border: none;
      border-radius: 25px;
      background: rgba(255, 255, 255, 0.1);
      color: var(--text);
      font-size: 16px;
      transition: background var(--transition);
    }

    .chat-input input:focus {
      outline: none;
      background: rgba(255, 255, 255, 0.15);
    }

    .chat-input input::placeholder {
      color: #666;
    }

    .chat-input button {
      width: 45px;
      height: 45px;
      border: none;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      flex-shrink: 0;
      transition: transform var(--transition), opacity var(--transition);
    }

    .chat-input button:active {
      transform: scale(0.95);
    }

    .chat-input button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .img-btn {
      background: rgba(255, 255, 255, 0.2);
      color: var(--text);
      font-size: 20px;
    }

    .send-btn {
      background: var(--primary);
      color: var(--text);
      font-size: 18px;
    }

    /* User Modal */
    .modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.9);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 100;
      backdrop-filter: blur(5px);
      -webkit-backdrop-filter: blur(5px);
    }

    .modal.show {
      display: flex;
    }

    .modal-content {
      background: var(--bg-card);
      border-radius: 16px;
      padding: 20px;
      width: 90%;
      max-width: 350px;
      max-height: 70%;
      overflow-y: auto;
    }

    .modal-content h3 {
      text-align: center;
      margin-bottom: 15px;
    }

    .user-item {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      background: rgba(255, 255, 255, 0.05);
      border-radius: 10px;
      margin-bottom: 10px;
    }

    .user-item .name {
      font-size: 15px;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .user-item .name .online-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--success);
    }

    .user-item .name .offline-dot {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: var(--text-muted);
    }

    .user-item.me .name {
      color: var(--text-muted);
    }

    .call-btn {
      background: var(--success);
      border: none;
      color: var(--text);
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 13px;
      cursor: pointer;
      transition: opacity var(--transition);
    }

    .call-btn:disabled {
      background: var(--text-muted);
      cursor: not-allowed;
    }

    .close-btn {
      width: 100%;
      padding: 12px;
      margin-top: 10px;
      background: #444;
      border: none;
      border-radius: 10px;
      color: var(--text);
      cursor: pointer;
    }

    /* Image Preview Modal */
    .preview-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.95);
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }

    .preview-modal.show {
      display: flex;
    }

    .preview-modal img {
      max-width: 90%;
      max-height: 60%;
      border-radius: 10px;
    }

    .preview-modal .btns {
      display: flex;
      gap: 15px;
      margin-top: 20px;
    }

    .preview-modal button {
      padding: 12px 30px;
      border: none;
      border-radius: 25px;
      font-size: 16px;
      cursor: pointer;
    }

    .preview-modal .cancel {
      background: #444;
      color: var(--text);
    }

    .preview-modal .send {
      background: var(--primary);
      color: var(--text);
    }

    /* Full Image Modal */
    .fullimg-modal {
      position: fixed;
      inset: 0;
      background: rgba(0, 0, 0, 0.98);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 150;
    }

    .fullimg-modal.show {
      display: flex;
    }

    .fullimg-modal img {
      max-width: 95%;
      max-height: 90%;
      object-fit: contain;
    }

    .fullimg-modal .close-full {
      position: absolute;
      top: 20px;
      right: 20px;
      background: rgba(255, 255, 255, 0.2);
      border: none;
      color: var(--text);
      width: 40px;
      height: 40px;
      border-radius: 50%;
      font-size: 24px;
      cursor: pointer;
    }

    /* Audio Call Screen */
    #callScreen {
      background: linear-gradient(135deg, var(--bg-dark), var(--bg-darker));
      z-index: 200;
      align-items: center;
      justify-content: center;
    }

    .call-container {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      flex: 1;
      width: 100%;
    }

    .call-avatar {
      width: 120px;
      height: 120px;
      background: linear-gradient(135deg, var(--primary), var(--primary-light));
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 60px;
      margin-bottom: 25px;
      box-shadow: 0 0 40px rgba(233, 69, 96, 0.4);
    }

    .call-avatar.ringing {
      animation: pulse-ring 1.5s infinite;
    }

    @keyframes pulse-ring {

      0%,
      100% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(233, 69, 96, 0.7);
      }

      50% {
        transform: scale(1.05);
        box-shadow: 0 0 0 20px rgba(233, 69, 96, 0);
      }
    }

    .call-avatar.connected {
      animation: pulse-connected 2s infinite;
      background: linear-gradient(135deg, var(--success), var(--success-light));
    }

    @keyframes pulse-connected {

      0%,
      100% {
        box-shadow: 0 0 40px rgba(34, 197, 94, 0.4);
      }

      50% {
        box-shadow: 0 0 60px rgba(34, 197, 94, 0.6);
      }
    }

    .call-name {
      font-size: 24px;
      font-weight: bold;
      margin-bottom: 10px;
    }

    .call-status-text {
      font-size: 16px;
      color: var(--text-muted);
      margin-bottom: 10px;
    }

    .call-timer {
      font-size: 18px;
      color: var(--success-light);
      font-family: monospace;
      margin-bottom: 40px;
    }

    .call-controls {
      display: flex;
      justify-content: center;
      gap: 30px;
      padding: 25px;
      position: absolute;
      bottom: 50px;
    }

    .ctrl-btn {
      width: 60px;
      height: 60px;
      border-radius: 50%;
      border: none;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 24px;
      transition: transform var(--transition), background var(--transition);
    }

    .ctrl-btn:active {
      transform: scale(0.95);
    }

    .ctrl-btn.end {
      background: var(--danger);
    }

    .ctrl-btn.mic {
      background: var(--info);
    }

    .ctrl-btn.speaker {
      background: #8b5cf6;
    }

    .ctrl-btn.off {
      background: #666;
    }

    /* Incoming Call */
    .incoming-modal {
      position: fixed;
      inset: 0;
      background: linear-gradient(135deg, var(--bg-dark), var(--bg-darker));
      display: none;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      z-index: 300;
    }

    .incoming-modal.show {
      display: flex;
    }

    .incoming-modal .avatar {
      width: 100px;
      height: 100px;
      background: linear-gradient(135deg, var(--success), var(--success-light));
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 50px;
      margin-bottom: 20px;
      animation: pulse 1.5s infinite;
    }

    @keyframes pulse {

      0%,
      100% {
        transform: scale(1);
        box-shadow: 0 0 0 0 rgba(34, 197, 94, 0.7);
      }

      50% {
        transform: scale(1.05);
        box-shadow: 0 0 0 20px rgba(34, 197, 94, 0);
      }
    }

    .incoming-modal h2 {
      margin-bottom: 10px;
    }

    .incoming-modal p {
      color: var(--text-muted);
      margin-bottom: 40px;
    }

    .incoming-modal .btns {
      display: flex;
      gap: 50px;
    }

    .incoming-modal .btns button {
      width: 65px;
      height: 65px;
      border-radius: 50%;
      border: none;
      cursor: pointer;
      font-size: 28px;
      transition: transform var(--transition);
    }

    .incoming-modal .btns button:active {
      transform: scale(0.95);
    }

    .incoming-modal .accept {
      background: var(--success);
    }

    .incoming-modal .reject {
      background: var(--danger);
    }

    /* Video Call Styles */
    .video-container {
      position: absolute;
      inset: 0;
      background: #000;
      display: none;
    }

    .video-container.active {
      display: block;
    }

    .remote-video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      background: #000;
    }

    .local-video-wrapper {
      position: absolute;
      top: 20px;
      right: 20px;
      width: 120px;
      height: 160px;
      border-radius: 12px;
      overflow: hidden;
      border: 2px solid rgba(255, 255, 255, 0.3);
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
      z-index: 10;
      cursor: move;
      transition: transform 0.2s;
    }

    .local-video-wrapper:active {
      transform: scale(1.05);
    }

    .local-video {
      width: 100%;
      height: 100%;
      object-fit: cover;
      transform: scaleX(-1);
      /* Mirror effect */
      background: #333;
    }

    .local-video.hidden {
      display: none;
    }

    .local-video-off {
      position: absolute;
      inset: 0;
      background: var(--bg-card);
      display: none;
      align-items: center;
      justify-content: center;
      font-size: 40px;
    }

    .local-video-wrapper.camera-off .local-video-off {
      display: flex;
    }

    .local-video-wrapper.camera-off .local-video {
      display: none;
    }

    /* Video call info overlay */
    .video-call-overlay {
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      padding: 20px;
      background: linear-gradient(to bottom, rgba(0, 0, 0, 0.7), transparent);
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      z-index: 5;
    }

    .video-call-info {
      color: #fff;
    }

    .video-call-info .name {
      font-size: 18px;
      font-weight: bold;
    }

    .video-call-info .timer {
      font-size: 14px;
      color: rgba(255, 255, 255, 0.8);
      font-family: monospace;
    }

    /* Video call controls */
    .video-call-controls {
      position: absolute;
      bottom: 0;
      left: 0;
      right: 0;
      padding: 30px 20px;
      padding-bottom: max(30px, env(safe-area-inset-bottom));
      background: linear-gradient(to top, rgba(0, 0, 0, 0.8), transparent);
      display: flex;
      justify-content: center;
      gap: 20px;
      z-index: 5;
    }

    .ctrl-btn.camera {
      background: #3b82f6;
    }

    .ctrl-btn.flip {
      background: #8b5cf6;
    }

    .ctrl-btn.camera.off,
    .ctrl-btn.flip.off {
      background: #666;
    }

    /* Call type buttons in user modal */
    .call-buttons {
      display: flex;
      gap: 8px;
    }

    .call-btn.audio-call {
      background: var(--success);
      padding: 8px 12px;
    }

    .call-btn.video-call {
      background: #3b82f6;
      padding: 8px 12px;
    }

    /* Remote video placeholder when no stream */
    .remote-video-placeholder {
      position: absolute;
      inset: 0;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      background: linear-gradient(135deg, var(--bg-dark), var(--bg-darker));
      z-index: 1;
    }

    .remote-video-placeholder .avatar {
      width: 120px;
      height: 120px;
      background: linear-gradient(135deg, var(--primary), var(--primary-light));
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 60px;
      margin-bottom: 20px;
    }

    .remote-video-placeholder.connected .avatar {
      background: linear-gradient(135deg, var(--success), var(--success-light));
    }

    .remote-video-placeholder.hidden {
      display: none;
    }

    /* Network Quality Indicator */
    .network-quality {
      position: absolute;
      top: 80px;
      right: 20px;
      display: flex;
      gap: 2px;
      align-items: flex-end;
    }

    .network-quality .bar {
      width: 4px;
      background: var(--success);
      border-radius: 2px;
      transition: height 0.3s, background 0.3s;
    }

    .network-quality .bar:nth-child(1) {
      height: 6px;
    }

    .network-quality .bar:nth-child(2) {
      height: 10px;
    }

    .network-quality .bar:nth-child(3) {
      height: 14px;
    }

    .network-quality .bar:nth-child(4) {
      height: 18px;
    }

    .network-quality.poor .bar {
      background: var(--danger);
    }

    .network-quality.fair .bar:nth-child(3),
    .network-quality.fair .bar:nth-child(4) {
      background: var(--text-muted);
    }

    .network-quality.poor .bar:nth-child(2),
    .network-quality.poor .bar:nth-child(3),
    .network-quality.poor .bar:nth-child(4) {
      background: var(--text-muted);
    }

    /* Audio Debug Info */
    .audio-debug {
      position: absolute;
      top: 120px;
      left: 20px;
      font-size: 11px;
      color: var(--text-muted);
      background: rgba(0, 0, 0, 0.5);
      padding: 8px;
      border-radius: 8px;
      display: none;
    }

    .audio-debug.show {
      display: block;
    }

    /* Audio Level Meter */
    .audio-meters {
      display: flex;
      gap: 20px;
      justify-content: center;
      align-items: flex-end;
      margin-bottom: 20px;
      height: 60px;
    }

    .audio-meter {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 5px;
    }

    .audio-meter-label {
      font-size: 10px;
      color: var(--text-muted);
      text-transform: uppercase;
    }

    .audio-meter-bars {
      display: flex;
      gap: 2px;
      align-items: flex-end;
      height: 40px;
    }

    .audio-meter-bar {
      width: 4px;
      background: var(--success);
      border-radius: 2px;
      transition: height 0.05s ease-out;
      min-height: 2px;
    }

    .audio-meter-bar.low {
      background: var(--success);
    }

    .audio-meter-bar.mid {
      background: var(--warning);
    }

    .audio-meter-bar.high {
      background: var(--danger);
    }

    .audio-meter.muted .audio-meter-bar {
      background: var(--text-muted) !important;
    }

    /* Network Quality Tooltip */
    .network-info {
      font-size: 10px;
      color: var(--text-muted);
      margin-top: 5px;
    }

    /* Debug */
    #debug {
      position: fixed;
      bottom: 70px;
      left: 5px;
      right: 5px;
      background: rgba(0, 0, 0, 0.95);
      border: 1px solid #333;
      border-radius: 8px;
      padding: 8px;
      font-size: 10px;
      max-height: 150px;
      overflow-y: auto;
      font-family: monospace;
      display: none;
      z-index: 999;
    }

    #debug.show {
      display: block;
    }

    #debug .log {
      color: #0f0;
      margin: 2px 0;
    }

    #debug .warn {
      color: #ff0;
      margin: 2px 0;
    }

    #debug .err {
      color: #f55;
      margin: 2px 0;
    }

    #debugBtn {
      position: fixed;
      bottom: 72px;
      right: 5px;
      background: #333;
      color: var(--text);
      border: none;
      padding: 5px 10px;
      border-radius: 5px;
      font-size: 10px;
      z-index: 1000;
      cursor: pointer;
    }

    /* Offline indicator */
    .offline-banner {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: var(--warning);
      color: #000;
      padding: 8px;
      text-align: center;
      font-size: 12px;
      font-weight: 500;
      transform: translateY(100%);
      transition: transform 0.3s ease;
      z-index: 1001;
    }

    .offline-banner.show {
      transform: translateY(0);
    }
  </style>
</head>

<body>

  <!-- Connection Status -->
  <div class="connection-status" id="connectionStatus">Connecting to server...</div>
  <script>
    // Show helpful message if connection is slow (server waking up)
    setTimeout(() => {
      const status = document.getElementById('connectionStatus');
      if (status.textContent.includes('Connecting')) {
        status.textContent = "Server might be waking up (free tier), please wait...";
      }
    }, 5000);
  </script>

  <!-- Offline Banner -->
  <div class="offline-banner" id="offlineBanner">You are offline. Messages will be sent when connection is restored.
  </div>

  <!-- Join Screen -->
  <div class="screen active" id="joinScreen">
    <div class="join-box">
      <h1>üîê</h1>
      <h2 style="margin-bottom: 10px;">Private Chat</h2>
      <p style="color: var(--text-muted); margin-bottom: 20px;">Secure Chat & Audio Calls</p>
      <input type="text" id="nameInput" placeholder="Your name" maxlength="20" autocomplete="off"
        autocapitalize="words">
      <input type="text" id="roomInput" placeholder="Room code" maxlength="30" autocomplete="off" autocapitalize="off">
      <button id="joinBtn">Join Room</button>
      <div class="error-msg" id="joinError"></div>
    </div>
  </div>

  <!-- Chat Screen -->
  <div class="screen" id="chatScreen">
    <div class="chat-header">
      <div>
        <h2 id="roomTitle">Room</h2>
        <div class="info" id="userInfo">
          <span class="status-dot"></span>
          <span id="userCount">0 online</span>
        </div>
      </div>
      <button class="leave-btn" id="leaveBtn">Leave</button>
    </div>
    <div class="messages-wrapper">
      <div class="messages" id="messages"></div>
    </div>
    <div class="typing-indicator" id="typingIndicator"></div>
    <div class="chat-input" id="chatInputArea">
      <button class="img-btn" id="imgBtn" aria-label="Send image">üñºÔ∏è</button>
      <input type="file" id="fileInput" accept="image/*" hidden>
      <input type="text" id="msgInput" placeholder="Type a message..." maxlength="1000" autocomplete="off"
        enterkeyhint="send">
      <button class="send-btn" id="sendBtn" aria-label="Send message">‚û§</button>
    </div>
  </div>

  <!-- User List Modal -->
  <div class="modal" id="userModal">
    <div class="modal-content">
      <h3>üë• Online Users</h3>
      <div id="userList"></div>
      <button class="close-btn" id="closeUserModal">Close</button>
    </div>
  </div>

  <!-- Image Preview Modal -->
  <div class="preview-modal" id="previewModal">
    <img id="previewImg" src="" alt="Preview">
    <div class="btns">
      <button class="cancel" id="cancelImg">Cancel</button>
      <button class="send" id="confirmImg">Send</button>
    </div>
  </div>

  <!-- Full Image Modal -->
  <div class="fullimg-modal" id="fullImgModal">
    <button class="close-full" id="closeFullImg" aria-label="Close">√ó</button>
    <img id="fullImg" src="" alt="Full size">
  </div>

  <!-- Incoming Call Modal -->
  <div class="incoming-modal" id="incomingModal">
    <div class="avatar" id="incomingCallAvatar">üìû</div>
    <h2 id="incomingCallType">Incoming Audio Call</h2>
    <p id="callerName">Someone is calling...</p>
    <div class="btns">
      <button class="reject" id="rejectBtn" aria-label="Reject call">‚úï</button>
      <button class="accept" id="acceptBtn" aria-label="Accept call">‚úì</button>
    </div>
  </div>

  <!-- Call Screen (Audio & Video) -->
  <div class="screen" id="callScreen">
    <!-- Video Container (hidden for audio calls) -->
    <div class="video-container" id="videoContainer">
      <!-- Remote video placeholder (shown while connecting) -->
      <div class="remote-video-placeholder" id="remoteVideoPlaceholder">
        <div class="avatar" id="videoCallAvatar">üìπ</div>
        <div class="call-name" id="videoCallName">User</div>
        <div class="call-status-text" id="videoCallStatus">Connecting...</div>
      </div>
      <video id="remoteVideo" class="remote-video" autoplay playsinline></video>
      <div class="local-video-wrapper" id="localVideoWrapper">
        <video id="localVideo" class="local-video" autoplay playsinline muted></video>
        <div class="local-video-off">üì∑</div>
      </div>
      <div class="video-call-overlay">
        <div class="video-call-info">
          <div class="name" id="videoOverlayName">User</div>
          <div class="timer" id="videoCallTimer">00:00</div>
        </div>
      </div>
      <div class="video-call-controls">
        <button class="ctrl-btn flip" id="flipCameraBtn" aria-label="Flip camera">üîÑ</button>
        <button class="ctrl-btn camera" id="cameraBtn" aria-label="Toggle camera">üìπ</button>
        <button class="ctrl-btn mic" id="videoMicBtn" aria-label="Toggle microphone">üé§</button>
        <button class="ctrl-btn end" id="videoEndBtn" aria-label="End call">‚úï</button>
      </div>
    </div>

    <!-- Audio-only call container -->
    <div class="call-container" id="audioCallContainer">
      <div class="call-avatar ringing" id="callAvatar">üìû</div>
      <div class="call-name" id="callName">User</div>
      <div class="call-status-text" id="callStatusText">Connecting...</div>
      <button id="reconnectBtn"
        style="display: none; margin-bottom: 20px; background: var(--warning); border: none; padding: 8px 16px; border-radius: 20px; color: #000; font-size: 14px; cursor: pointer;">‚Üª
        Reconnect</button>
      <div class="call-timer" id="callTimer">00:00</div>
      <div class="network-quality" id="networkQuality">
        <div class="bar"></div>
        <div class="bar"></div>
        <div class="bar"></div>
        <div class="bar"></div>
      </div>
      <div class="network-info" id="networkInfo">Checking...</div>

      <!-- Audio Level Meters -->
      <div class="audio-meters" id="audioMeters">
        <div class="audio-meter" id="localMeter">
          <div class="audio-meter-bars">
            <div class="audio-meter-bar"></div>
            <div class="audio-meter-bar"></div>
            <div class="audio-meter-bar"></div>
            <div class="audio-meter-bar"></div>
            <div class="audio-meter-bar"></div>
          </div>
          <div class="audio-meter-label">You</div>
        </div>
        <div class="audio-meter" id="remoteMeter">
          <div class="audio-meter-bars">
            <div class="audio-meter-bar"></div>
            <div class="audio-meter-bar"></div>
            <div class="audio-meter-bar"></div>
            <div class="audio-meter-bar"></div>
            <div class="audio-meter-bar"></div>
          </div>
          <div class="audio-meter-label">Them</div>
        </div>
      </div>
      <div id="callStats" style="font-size: 12px; color: yellow; margin-bottom: 10px; font-family: monospace;">Waiting
        for data...</div>
      <div class="audio-debug" id="audioDebug"></div>
    </div>
    <div class="call-controls" id="audioCallControls">
      <button class="ctrl-btn speaker" id="speakerBtn" aria-label="Toggle speaker">üîä</button>
      <button class="ctrl-btn mic" id="micBtn" aria-label="Toggle microphone">üé§</button>
      <button class="ctrl-btn" id="testAudioBtn"
        style="background: #e94560; font-size: 14px; width: auto; padding: 0 15px; border-radius: 20px;">Test
        Sound</button>
      <button class="ctrl-btn end" id="endBtn" aria-label="End call">‚úï</button>
    </div>
    <!-- Audio elements -->
    <audio id="remoteAudio" autoplay playsinline></audio>
    <audio id="localAudioMonitor" muted></audio>
  </div>

  <button id="debugBtn">DEBUG</button>
  <div id="debug"></div>

  <script src="/socket.io/socket.io.js"></script>
  <script>
    'use strict';

    // ===== DEBUG LOGGER =====
    const debugEl = document.getElementById('debug');
    const debugBtn = document.getElementById('debugBtn');
    const audioDebugEl = document.getElementById('audioDebug');

    debugBtn.addEventListener('click', () => {
      debugEl.classList.toggle('show');
      audioDebugEl.classList.toggle('show');
    });

    function log(msg, level = 'log') {
      console.log(msg);
      const div = document.createElement('div');
      div.className = level;
      div.textContent = new Date().toLocaleTimeString().slice(0, 8) + ' ' + msg;
      debugEl.appendChild(div);
      debugEl.scrollTop = debugEl.scrollHeight;
      if (debugEl.children.length > 200) debugEl.firstChild.remove();
    }

    // ===== SERVER PRE-WARMING (Wake up sleeping Render server) =====
    let serverReady = false;
    let serverWakeupStartTime = 0;
    let wakeupAttempts = 0;
    const MAX_WAKEUP_ATTEMPTS = 30; // 30 attempts * 2 seconds = 60 seconds max

    // Helper to show status before showConnectionStatus is defined
    function showWakeupStatus(message) {
      // Try to use showConnectionStatus if available
      if (typeof showConnectionStatus === 'function') {
        const statusType = message.includes('ready') ? 'connected' :
          message.includes('unavailable') ? 'disconnected' : 'connecting';
        showConnectionStatus(statusType, message);
      } else {
        // Fallback: update connection-status element directly if it exists
        const statusEl = document.querySelector('.connection-status');
        if (statusEl) {
          statusEl.textContent = message;
          statusEl.className = 'connection-status show connecting';
        }
      }
    }

    // Pre-warm the server immediately
    async function prewarmServer() {
      serverWakeupStartTime = Date.now();
      log('üîÑ Waking up server...');

      const prewarmWithRetry = async () => {
        if (serverReady) return true;

        wakeupAttempts++;
        const elapsed = Math.floor((Date.now() - serverWakeupStartTime) / 1000);

        try {
          const controller = new AbortController();
          const timeout = setTimeout(() => controller.abort(), 8000); // 8 second timeout

          const startTime = performance.now();
          const response = await fetch('/health', {
            signal: controller.signal,
            cache: 'no-store'
          });
          clearTimeout(timeout);

          if (response.ok) {
            const latency = Math.round(performance.now() - startTime);
            const data = await response.json();
            serverReady = true;
            log(`‚úÖ Server ready! (uptime: ${data.uptime}, latency: ${latency}ms)`);
            showWakeupStatus('Server ready');
            return true;
          }
        } catch (err) {
          // Server still waking up
          if (wakeupAttempts < MAX_WAKEUP_ATTEMPTS) {
            if (elapsed < 10) {
              showWakeupStatus('‚è≥ Connecting to server...');
            } else if (elapsed < 30) {
              showWakeupStatus(`‚è≥ Server waking up... (${elapsed}s)`);
            } else {
              showWakeupStatus(`‚è≥ Still waking up... (${elapsed}s)`);
            }

            // Retry with exponential backoff (max 3 seconds)
            const delay = Math.min(1000 + (wakeupAttempts * 200), 3000);
            await new Promise(r => setTimeout(r, delay));
            return prewarmWithRetry();
          } else {
            log('‚ùå Server wake-up timeout', 'err');
            showWakeupStatus('Server unavailable. Try refreshing.');
            return false;
          }
        }
        return false;
      };

      return prewarmWithRetry();
    }

    // Start pre-warming immediately (uses fallback status display)
    prewarmServer();

    // ===== STATE =====
    let myName = '';
    let myRoom = '';
    let myId = '';
    let mySessionId = localStorage.getItem('chatSessionId') || '';
    let users = [];
    let pendingImage = null;
    let typingTimeout = null;
    let isTyping = false;
    const typingUsers = new Map();
    let unseenMessages = [];
    let shouldAutoScroll = true;
    let messageQueue = [];
    let isConnected = false;
    let isOnline = navigator.onLine;
    let pendingMessages = new Map(); // Track optimistic messages
    let messageLatency = []; // Track message delivery times

    // Network stability state
    let connectionQuality = 'good'; // 'good', 'fair', 'poor'
    let lastPingTime = 0;
    let pingInterval = null;
    let missedPongs = 0;
    let reconnectCount = 0;
    let lastConnectedTime = 0;
    let networkType = 'unknown';

    // Background Connection Keep-Alive State
    let backgroundKeepAliveActive = false;
    let backgroundHeartbeatInterval = null;
    let wakeLock = null;
    let isInBackground = false;
    let chatKeepAliveInterval = null;

    // WebRTC State
    let pc = null;
    let localStream = null;
    let remoteStream = null;
    let callTarget = null;
    let callTargetName = '';
    let incomingData = null;
    let iceQueue = [];
    let micOff = false;
    let speakerOff = false;
    let speakerMode = false; // false = earpiece, true = speaker
    let callTimer = null;
    let callSeconds = 0;
    let audioContext = null;
    let iceServers = null;
    let statsInterval = null;
    let keepAliveInterval = null;
    let isCallConnected = false;
    let remoteDescriptionSet = false;
    let audioOutputDevices = [];

    // Video Call State
    let isVideoCall = false;       // Track if current call is video
    let cameraOff = false;         // Camera mute state
    let facingMode = 'user';       // 'user' (front) or 'environment' (back)

    // Helper: Handle old encrypted messages that can't be decrypted anymore
    function cleanMessageText(text) {
      if (text && text.startsWith('ENC::v1::')) {
        return 'üîí [Encrypted message - sent before encryption was disabled]';
      }
      return text;
    }

    // DOM Elements
    const remoteAudioEl = document.getElementById('remoteAudio');
    const localAudioMonitor = document.getElementById('localAudioMonitor');
    const msgInput = document.getElementById('msgInput');
    const chatScreen = document.getElementById('chatScreen');
    const messagesEl = document.getElementById('messages');
    const connectionStatus = document.getElementById('connectionStatus');
    const joinError = document.getElementById('joinError');
    const offlineBanner = document.getElementById('offlineBanner');

    // Video Call DOM Elements
    const videoContainer = document.getElementById('videoContainer');
    const remoteVideoEl = document.getElementById('remoteVideo');
    const localVideoEl = document.getElementById('localVideo');
    const localVideoWrapper = document.getElementById('localVideoWrapper');
    const remoteVideoPlaceholder = document.getElementById('remoteVideoPlaceholder');
    const audioCallContainer = document.getElementById('audioCallContainer');
    const audioCallControls = document.getElementById('audioCallControls');

    // ===== ONLINE/OFFLINE HANDLERS =====
    window.addEventListener('online', () => {
      log('App is online');
      isOnline = true;
      offlineBanner.classList.remove('show');
      detectNetworkType();
      if (!socket.connected) {
        socket.connect();
      }
      // Retry pending messages
      retryPendingMessages();
    });

    window.addEventListener('offline', () => {
      log('App is offline', 'warn');
      isOnline = false;
      offlineBanner.classList.add('show');
      connectionQuality = 'poor';
    });

    // ===== NETWORK TYPE DETECTION =====
    function detectNetworkType() {
      if ('connection' in navigator) {
        const conn = navigator.connection;
        networkType = conn.effectiveType || conn.type || 'unknown';
        log('Network type: ' + networkType + ', downlink: ' + (conn.downlink || 'unknown') + ' Mbps');

        // Adjust behavior based on network type
        if (networkType === 'slow-2g' || networkType === '2g') {
          connectionQuality = 'poor';
        } else if (networkType === '3g') {
          connectionQuality = 'fair';
        } else {
          connectionQuality = 'good';
        }

        // Listen for network changes
        conn.addEventListener('change', () => {
          detectNetworkType();
          log('Network changed to: ' + networkType, 'warn');
        });
      }
    }

    detectNetworkType();

    // ===== CONNECTION QUALITY MONITORING =====
    function startConnectionMonitoring() {
      if (pingInterval) clearInterval(pingInterval);

      // Ping interval based on network quality
      const interval = connectionQuality === 'poor' ? 5000 :
        connectionQuality === 'fair' ? 10000 : 15000;

      pingInterval = setInterval(() => {
        if (!isConnected || !isOnline) return;

        lastPingTime = performance.now();
        socket.emit('heartbeat');

        // Check for missed response after timeout
        setTimeout(() => {
          if (missedPongs >= 2) {
            log('Connection unstable - missed pongs: ' + missedPongs, 'warn');
            connectionQuality = 'poor';
            showConnectionStatus('reconnecting', 'Connection unstable...');

            // Force reconnect if too many missed
            if (missedPongs >= 4) {
              log('Forcing reconnection due to missed heartbeats', 'err');
              socket.disconnect();
              setTimeout(() => socket.connect(), 500);
              missedPongs = 0;
            }
          }
          missedPongs++;
        }, 3000);

      }, interval);
    }

    function stopConnectionMonitoring() {
      if (pingInterval) {
        clearInterval(pingInterval);
        pingInterval = null;
      }
    }

    // ===== MESSAGE RETRY SYSTEM =====
    function retryPendingMessages() {
      if (!isConnected || pendingMessages.size === 0) return;

      log('Retrying ' + pendingMessages.size + ' pending messages...');

      pendingMessages.forEach((pending, tempId) => {
        const data = pending.data;
        if (data.type === 'text') {
          socket.emit('message', data.text, (response) => {
            if (response && response.status === 'ok') {
              updateMessageStatus(tempId, 'delivered');
              pendingMessages.delete(tempId);
            }
          });
        }
      });
    }

    // Retry failed messages periodically
    setInterval(() => {
      if (isConnected && isOnline) {
        retryPendingMessages();
      }
    }, 30000);

    // ===== FETCH ICE SERVERS =====
    async function fetchIceServers() {
      try {
        const response = await fetch('/api/ice-servers');
        const data = await response.json();
        iceServers = data;
        log('ICE servers loaded: ' + data.iceServers.length + ' servers');
      } catch (err) {
        log('Failed to fetch ICE servers, using defaults', 'warn');
        iceServers = getDefaultIceServers();
      }
    }

    function getDefaultIceServers() {
      return {
        iceServers: [
          // Google STUN servers (reliable)
          { urls: 'stun:stun.l.google.com:19302' },
          { urls: 'stun:stun1.l.google.com:19302' },
          { urls: 'stun:stun2.l.google.com:19302' },
          { urls: 'stun:stun3.l.google.com:19302' },
          { urls: 'stun:stun4.l.google.com:19302' },
          // Other free STUN servers
          { urls: 'stun:global.stun.twilio.com:3478' },
          { urls: 'stun:stun.framasoft.org:3478' },
          // Free TURN servers (for NAT traversal)
          {
            urls: 'turn:openrelay.metered.ca:80',
            username: 'openrelayproject',
            credential: 'openrelayproject'
          },
          {
            urls: 'turn:openrelay.metered.ca:443',
            username: 'openrelayproject',
            credential: 'openrelayproject'
          },
          {
            urls: 'turn:openrelay.metered.ca:443?transport=tcp',
            username: 'openrelayproject',
            credential: 'openrelayproject'
          },
          // Additional free TURN servers for redundancy
          {
            urls: 'turn:relay.metered.ca:80',
            username: 'e8dd65f92c95c6bf4bf1',
            credential: 'DQpDQkhS3f/L4bsi'
          },
          {
            urls: 'turn:relay.metered.ca:443',
            username: 'e8dd65f92c95c6bf4bf1',
            credential: 'DQpDQkhS3f/L4bsi'
          }
        ]
        // NOTE: iceCandidatePoolSize is set in createPC, not here
      };
    }

    fetchIceServers();

    // ===== SOCKET.IO CONNECTION (Optimized for Slow Networks & Fast Reconnection) =====
    const socket = io({
      // Reconnection settings - very aggressive for poor/slow networks
      reconnection: true,
      reconnectionAttempts: Infinity,
      reconnectionDelay: 300,        // Start trying VERY quickly (300ms)
      reconnectionDelayMax: 2000,    // Max 2 seconds between retries
      randomizationFactor: 0.2,      // Less randomization for faster reconnects

      // Timeout settings - balanced for slow networks but fast detection
      timeout: 20000,                // 20 second connection timeout (longer for slow networks)

      // Transport settings - start with polling for reliability on slow networks
      transports: ['polling', 'websocket'],  // Polling first for reliability
      upgrade: true,                          // Try to upgrade to websocket
      rememberUpgrade: false,                 // Always start fresh for reliability

      // Force new connection on reconnect
      forceNew: false,

      // Multiplexing
      multiplex: true,

      // Additional slow network support
      autoConnect: true,            // Connect immediately
      withCredentials: false
    });

    // ===== CONNECTION STATUS UI =====
    function showConnectionStatus(status, message) {
      connectionStatus.textContent = message;
      connectionStatus.className = 'connection-status show ' + status;
      if (status === 'connected') {
        setTimeout(() => connectionStatus.classList.remove('show'), 2000);
      }
    }

    // ===== SOCKET EVENT HANDLERS =====
    socket.on('connect', () => {
      myId = socket.id;
      isConnected = true;
      missedPongs = 0;
      lastConnectedTime = Date.now();

      log('Connected: ' + myId + ' (transport: ' + socket.io.engine.transport.name + ')');
      showConnectionStatus('connected', 'Connected');

      // Start monitoring connection quality
      startConnectionMonitoring();

      if (mySessionId && myRoom && myName) {
        log('Attempting to rejoin...');
        socket.emit('rejoin', { sessionId: mySessionId, roomCode: myRoom, username: myName });
      }

      // Retry queued messages
      while (messageQueue.length > 0 && isConnected) {
        const msg = messageQueue.shift();
        socket.emit(msg.type, msg.data);
      }

      // Retry pending messages
      setTimeout(() => retryPendingMessages(), 1000);
    });

    // ===== KEEP-ALIVE PING =====
    // Periodically fetch HTTP endpoint to keep server awake (more aggressive)
    setInterval(() => {
      if (isOnline) {
        fetch('/ping', { cache: 'no-store' }).catch(() => { });
      }
    }, 3 * 60 * 1000); // Pulse every 3 minutes

    socket.on('disconnect', (reason) => {
      isConnected = false;
      reconnectCount++;
      stopConnectionMonitoring();

      log('Disconnected: ' + reason + ' (reconnects: ' + reconnectCount + ')', 'warn');

      // Different messages based on reason
      if (reason === 'io server disconnect') {
        showConnectionStatus('disconnected', 'Server disconnected');
        // Server initiated disconnect, need to manually reconnect
        setTimeout(() => socket.connect(), 1000);
      } else if (reason === 'transport close' || reason === 'transport error') {
        showConnectionStatus('reconnecting', 'Connection lost, reconnecting...');
      } else if (reason === 'ping timeout') {
        showConnectionStatus('reconnecting', 'Connection timeout, reconnecting...');
      } else {
        showConnectionStatus('disconnected', 'Disconnected');
      }
    });

    socket.on('connect_error', (error) => {
      log('Connection error: ' + error.message, 'err');

      // Provide helpful message based on error
      if (error.message.includes('timeout')) {
        showConnectionStatus('reconnecting', 'Connection slow, retrying...');
      } else if (error.message.includes('xhr')) {
        showConnectionStatus('reconnecting', 'Network issue, retrying...');
      } else {
        showConnectionStatus('disconnected', 'Connection failed');
      }
    });

    socket.io.on('reconnect_attempt', (attempt) => {
      log('Reconnection attempt: ' + attempt, 'warn');
      showConnectionStatus('reconnecting', 'Reconnecting... (' + attempt + ')');
    });

    socket.io.on('reconnect', (attempt) => {
      log('Reconnected after ' + attempt + ' attempts');
      showConnectionStatus('connected', 'Reconnected');
      connectionQuality = 'good';
      missedPongs = 0;
    });

    socket.io.on('reconnect_failed', () => {
      log('Reconnection failed after max attempts', 'err');
      showConnectionStatus('disconnected', 'Could not reconnect. Tap to retry.');

      // Allow manual retry on tap
      connectionStatus.onclick = () => {
        socket.connect();
        connectionStatus.onclick = null;
      };
    });

    // Handle transport upgrade/downgrade
    socket.io.engine.on('upgrade', (transport) => {
      log('Transport upgraded to: ' + transport.name);
    });

    socket.io.engine.on('upgradeError', (err) => {
      log('Transport upgrade failed: ' + err.message, 'warn');
      // Stay on polling, which is more reliable for poor networks
    });

    // Heartbeat response handler
    socket.on('heartbeat_ack', () => {
      missedPongs = 0;
      const latency = Math.round(performance.now() - lastPingTime);

      // Update connection quality based on latency
      if (latency < 200) {
        connectionQuality = 'good';
      } else if (latency < 500) {
        connectionQuality = 'fair';
      } else {
        connectionQuality = 'poor';
      }

      // Log occasionally
      if (Math.random() < 0.1) {
        log('Ping: ' + latency + 'ms, quality: ' + connectionQuality);
      }
    });

    socket.on('yourSocketId', (id) => {
      myId = id;
      log('Socket ID: ' + id);
    });

    socket.on('error', (err) => {
      const message = typeof err === 'string' ? err : err.message;
      log('Error: ' + message, 'err');
      if (err.type === 'duplicate' || err.type === 'validation') {
        joinError.textContent = message;
      } else {
        alert(message);
      }
    });

    socket.on('joinSuccess', async (data) => {
      myRoom = data.room;
      myName = data.username;
      myId = data.socketId;
      mySessionId = data.sessionId;

      localStorage.setItem('chatSessionId', mySessionId);
      localStorage.setItem('chatRoom', myRoom);
      localStorage.setItem('chatName', myName);

      log('Joined room: ' + myRoom);

      document.getElementById('joinScreen').classList.remove('active');
      chatScreen.classList.add('active');
      document.getElementById('roomTitle').textContent = 'üí¨ ' + myRoom;
      addSystemMessage('Welcome! Tap user count to make audio calls.');
      addSystemMessage('üí° Chat stays connected in background until you leave.');

      requestNotificationPermission();

      // Request wake lock to keep connection alive
      requestWakeLock();
    });

    socket.on('rejoinSuccess', (data) => {
      myRoom = data.room;
      myName = data.username;
      myId = data.socketId;
      mySessionId = data.sessionId;

      log('Rejoined room: ' + myRoom);
      addSystemMessage('Reconnected to room');

      if (!chatScreen.classList.contains('active')) {
        document.getElementById('joinScreen').classList.remove('active');
        chatScreen.classList.add('active');
        document.getElementById('roomTitle').textContent = 'üí¨ ' + myRoom;
      }

      // Re-acquire wake lock on rejoin
      requestWakeLock();
    });

    socket.on('rejoinFailed', (data) => {
      log('Rejoin failed: ' + data.message, 'warn');
      localStorage.removeItem('chatSessionId');
      localStorage.removeItem('chatRoom');
      localStorage.removeItem('chatName');
      mySessionId = '';
    });

    socket.on('messageHistory', (messages) => {
      log('Received ' + messages.length + ' history messages');
      for (const data of messages) {
        if (data.type === 'image' && data.imageData === '[IMAGE]') continue;

        // Clean old encrypted messages
        if (data.type === 'text') {
          data.text = cleanMessageText(data.text);
        }

        const isMine = data.senderId === myId;
        addMessage(data, isMine ? 'mine' : 'other', true);
      }
      scrollToBottom(true);
    });

    socket.on('userList', (list) => {
      users = list;
      const onlineCount = list.filter(u => u.online !== false).length;
      document.getElementById('userCount').textContent = onlineCount + ' online';
      log('Users: ' + list.map(u => u.username + (u.online === false ? '(offline)' : '')).join(', '));
    });

    socket.on('userJoined', (data) => addSystemMessage(data.username + ' joined'));
    socket.on('userLeft', (data) => {
      addSystemMessage(data.username + ' left');
      typingUsers.delete(data.socketId);
      updateTypingUI();
    });
    socket.on('userOffline', (data) => {
      typingUsers.delete(data.socketId);
      updateTypingUI();
    });

    // ===== MESSAGE HANDLERS =====
    socket.on('message', (data) => {
      const isMine = data.senderId === myId;

      // Always skip our own messages from broadcast
      // We show them optimistically and the callback handles status updates
      if (isMine) {
        return;
      }

      // Clean old encrypted messages
      if (data.type === 'text') {
        data.text = cleanMessageText(data.text);
      }

      addMessage(data, 'other');

      typingUsers.delete(data.senderId);
      updateTypingUI();

      if (document.hasFocus() && shouldAutoScroll) {
        socket.emit('markSeen', [data.id]);
      } else {
        unseenMessages.push(data.id);
        if (!document.hasFocus()) {
          showLocalNotification(
            data.username,
            data.type === 'image' ? 'üì∑ Sent an image' : data.text.slice(0, 100),
            { messageId: data.id, roomCode: myRoom }
          );
        }
      }
    });

    socket.on('messageSeen', (data) => {
      const tickEl = document.getElementById('tick-' + data.messageId);
      if (tickEl && !tickEl.classList.contains('seen')) {
        tickEl.textContent = '‚úì‚úì';
        tickEl.classList.remove('delivered');
        tickEl.classList.add('seen');
      }
    });

    // ===== TYPING INDICATORS =====
    socket.on('typing', (data) => {
      typingUsers.set(data.socketId, { username: data.username, timestamp: Date.now() });
      updateTypingUI();
      setTimeout(() => {
        const user = typingUsers.get(data.socketId);
        if (user && Date.now() - user.timestamp > 2500) {
          typingUsers.delete(data.socketId);
          updateTypingUI();
        }
      }, 3000);
    });

    socket.on('stopTyping', (data) => {
      typingUsers.delete(data.socketId);
      updateTypingUI();
    });

    function updateTypingUI() {
      const names = Array.from(typingUsers.values()).map(u => u.username);
      const el = document.getElementById('typingIndicator');
      if (names.length === 0) {
        el.innerHTML = '';
      } else {
        const text = names.length === 1
          ? names[0] + ' is typing'
          : names.length === 2
            ? names[0] + ' and ' + names[1] + ' are typing'
            : names.length + ' people are typing';
        el.innerHTML = text + '<span class="typing-dots"><span></span><span></span><span></span></span>';
      }
    }

    window.addEventListener('focus', () => {
      if (unseenMessages.length > 0) {
        socket.emit('markSeen', unseenMessages);
        unseenMessages = [];
      }
      // Resume background keep-alive when coming back to foreground
      if (myRoom && isConnected) {
        backgroundKeepAliveActive = false; // Reset to normal mode
        // Note: stopChatKeepAlive() is called in visibilitychange handler
        log('Returned to foreground, normal mode resumed');
      }
    });

    // Regular heartbeat - more aggressive for better connection maintenance
    setInterval(() => {
      if (isConnected && myRoom) socket.emit('heartbeat');
    }, 15000); // Reduced from 30s to 15s

    // ===== WEBRTC SIGNALING =====
    socket.on('incomingCall', (data) => {
      const callType = data.isVideo ? 'video' : 'audio';
      log((data.isVideo ? 'üìπ' : 'üìû') + ' Incoming ' + callType + ' call from: ' + data.callerName);

      if (document.getElementById('callScreen').classList.contains('active')) {
        socket.emit('rejectCall', { targetId: data.callerId });
        return;
      }

      incomingData = data;
      isVideoCall = data.isVideo || false;

      // Update incoming call modal UI based on call type
      document.getElementById('incomingCallAvatar').textContent = data.isVideo ? 'üìπ' : 'üìû';
      document.getElementById('incomingCallType').textContent = 'Incoming ' + (data.isVideo ? 'Video' : 'Audio') + ' Call';
      document.getElementById('callerName').textContent = data.callerName + ' is calling...';
      document.getElementById('incomingModal').classList.add('show');

      if (!document.hasFocus()) {
        showLocalNotification(
          (data.isVideo ? 'üìπ' : 'üìû') + ' Incoming ' + (data.isVideo ? 'Video' : 'Audio') + ' Call',
          data.callerName + ' is calling...',
          { type: 'call' }
        );
      }

      if (navigator.vibrate) navigator.vibrate([200, 100, 200, 100, 200]);

      // Pre-initialize audio context on incoming call
      initAudioContext();
    });

    socket.on('callAnswered', async (data) => {
      log('Call answered, setting remote description...');
      if (pc && pc.signalingState !== 'closed') {
        try {
          await pc.setRemoteDescription(new RTCSessionDescription(data.answer));
          remoteDescriptionSet = true;
          log('Remote description set successfully');
          processIceQueue();
        } catch (e) {
          log('Error setting remote description: ' + e.message, 'err');
        }
      }
    });

    socket.on('iceCandidate', (data) => {
      log('Received ICE candidate from ' + data.from);

      if (!pc || pc.signalingState === 'closed') {
        log('PC not ready, queueing ICE candidate');
        iceQueue.push(data.candidate);
        return;
      }

      if (!remoteDescriptionSet) {
        log('Remote description not set, queueing ICE candidate');
        iceQueue.push(data.candidate);
        return;
      }

      addIceCandidate(data.candidate);
    });

    socket.on('callEnded', (data) => {
      log('Call ended by ' + (data.username || 'remote'));
      addSystemMessage('Call ended');
      cleanupCall();
    });

    socket.on('callRejected', (data) => {
      log('Call rejected');
      addSystemMessage('Call declined');
      cleanupCall();
    });

    socket.on('callTimeout', () => {
      log('Call timeout');
      addSystemMessage('No answer');
      cleanupCall();
    });

    socket.on('callCancelled', () => {
      log('Call cancelled');
      document.getElementById('incomingModal').classList.remove('show');
      incomingData = null;
    });

    socket.on('callError', (data) => {
      log('Call error: ' + data.message, 'err');
      alert(data.message);
      cleanupCall();
    });

    // ===== JOIN HANDLERS =====
    document.getElementById('joinBtn').addEventListener('click', joinRoom);
    document.getElementById('nameInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') document.getElementById('roomInput').focus();
    });
    document.getElementById('roomInput').addEventListener('keypress', (e) => {
      if (e.key === 'Enter') joinRoom();
    });

    function joinRoom() {
      const name = document.getElementById('nameInput').value.trim();
      const room = document.getElementById('roomInput').value.trim();

      joinError.textContent = '';

      if (!name) {
        joinError.textContent = 'Please enter your name';
        document.getElementById('nameInput').focus();
        return;
      }
      if (!room) {
        joinError.textContent = 'Please enter a room code';
        document.getElementById('roomInput').focus();
        return;
      }
      if (!isConnected) {
        joinError.textContent = 'Not connected. Please wait...';
        return;
      }

      log('Joining room: ' + room);

      // E2E Key will be derived in joinSuccess handler
      socket.emit('join', { username: name, roomCode: room, sessionId: mySessionId });
    }

    // ===== KEYBOARD & VIEWPORT =====
    const initialViewportHeight = window.innerHeight;

    if (window.visualViewport) {
      window.visualViewport.addEventListener('resize', handleViewportResize);
      window.visualViewport.addEventListener('scroll', handleViewportResize);
    }

    function handleViewportResize() {
      if (!chatScreen.classList.contains('active')) return;
      const viewport = window.visualViewport;
      chatScreen.style.height = viewport.height + 'px';
      chatScreen.style.transform = 'translateY(' + viewport.offsetTop + 'px)';
      setTimeout(() => scrollToBottom(true), 100);
    }

    msgInput.addEventListener('focus', () => {
      setTimeout(() => {
        scrollToBottom(true);
        msgInput.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
      }, 300);
    });

    msgInput.addEventListener('blur', () => {
      setTimeout(() => {
        if (window.visualViewport) {
          chatScreen.style.height = '100%';
          chatScreen.style.transform = 'none';
        }
      }, 100);
    });

    // ===== AUDIO CONTEXT INIT (CRITICAL FOR MOBILE) =====
    function initAudioContext() {
      if (!audioContext) {
        try {
          audioContext = new (window.AudioContext || window.webkitAudioContext)({
            latencyHint: 'interactive',
            sampleRate: 48000
          });
          log('AudioContext created: ' + audioContext.state);
        } catch (e) {
          log('AudioContext error: ' + e.message, 'err');
        }
      }

      if (audioContext && audioContext.state === 'suspended') {
        audioContext.resume().then(() => {
          log('AudioContext resumed');
        }).catch(e => {
          log('AudioContext resume failed: ' + e.message, 'err');
        });
      }
    }

    // Initialize audio context on any user interaction
    ['click', 'touchstart', 'touchend'].forEach(event => {
      document.addEventListener(event, () => initAudioContext(), { once: false, passive: true });
    });

    // ===== SCROLL HANDLING =====
    messagesEl.addEventListener('scroll', () => {
      const threshold = 100;
      const distanceFromBottom = messagesEl.scrollHeight - messagesEl.scrollTop - messagesEl.clientHeight;
      shouldAutoScroll = distanceFromBottom < threshold;
    });

    function scrollToBottom(force) {
      if (force || shouldAutoScroll) {
        requestAnimationFrame(() => {
          messagesEl.scrollTop = messagesEl.scrollHeight;
        });
      }
    }

    // ===== MESSAGE FUNCTIONS =====
    function addSystemMessage(text) {
      const div = document.createElement('div');
      div.className = 'msg sys';
      div.textContent = text;
      messagesEl.appendChild(div);
      scrollToBottom(true);
    }

    function formatTimestamp(timestamp) {
      try {
        return new Date(timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
      } catch {
        return timestamp;
      }
    }

    function addMessage(data, type, isHistory = false, isPending = false) {
      // Check if message already exists (for optimistic updates)
      const existingMsg = document.getElementById('msg-' + data.id);
      if (existingMsg && !isPending) {
        // Update existing pending message to confirmed
        existingMsg.classList.remove('pending');
        const tickEl = existingMsg.querySelector('.ticks');
        if (tickEl && tickEl.classList.contains('sending')) {
          tickEl.classList.remove('sending');
          tickEl.classList.add('delivered');
          tickEl.textContent = '‚úì';
        }
        return;
      }

      const div = document.createElement('div');
      div.className = 'msg ' + type + (isPending ? ' pending' : '');
      div.id = 'msg-' + data.id;
      div.dataset.senderId = data.senderId;

      let html = '';
      if (type === 'other') {
        html += '<div class="sender">' + escapeHtml(data.username) + '</div>';
      }

      if (data.type === 'image' && data.imageData && data.imageData !== '[IMAGE]') {
        html += '<div class="text"><img src="' + data.imageData + '" onclick="showFullImage(this.src)" loading="lazy" alt="Image"></div>';
      } else if (data.type === 'text') {
        html += '<div class="text">' + escapeHtml(data.text) + '</div>';
      }

      html += '<div class="meta">';
      html += '<span class="time">' + formatTimestamp(data.timestamp) + '</span>';
      if (type === 'mine') {
        if (isPending) {
          html += '<span class="ticks sending" id="tick-' + data.id + '">‚óã</span>';
        } else {
          html += '<span class="ticks delivered" id="tick-' + data.id + '">‚úì</span>';
        }
      }
      html += '</div>';

      div.innerHTML = html;
      messagesEl.appendChild(div);
      if (!isHistory) scrollToBottom(type === 'mine');
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    window.showFullImage = function (src) {
      document.getElementById('fullImg').src = src;
      document.getElementById('fullImgModal').classList.add('show');
    };

    document.getElementById('closeFullImg').addEventListener('click', () => {
      document.getElementById('fullImgModal').classList.remove('show');
    });

    document.getElementById('fullImgModal').addEventListener('click', function (e) {
      if (e.target === this) this.classList.remove('show');
    });

    // ===== SEND MESSAGE =====
    document.getElementById('sendBtn').addEventListener('click', sendMessage);
    msgInput.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        sendMessage();
      }
    });

    msgInput.addEventListener('input', () => {
      if (!isTyping) {
        isTyping = true;
        socket.emit('typing');
      }
      clearTimeout(typingTimeout);
      typingTimeout = setTimeout(() => {
        isTyping = false;
        socket.emit('stopTyping');
      }, 2000);
    });

    function sendMessage() {
      const text = msgInput.value.trim();
      if (!text) return;

      // Generate temporary ID for optimistic update
      const tempId = 'temp-' + Date.now() + '-' + Math.random().toString(36).substr(2, 9);
      const timestamp = new Date().toISOString();
      const sendTime = performance.now();

      // Clear input immediately for faster UX
      msgInput.value = '';
      isTyping = false;

      // Optimistic UI update - show message immediately
      const optimisticData = {
        id: tempId,
        type: 'text',
        username: myName,
        senderId: myId,
        text: text,
        timestamp: timestamp
      };

      addMessage(optimisticData, 'mine', false, true); // true = pending
      pendingMessages.set(tempId, { data: optimisticData, sendTime: sendTime });

      if (!isConnected) {
        messageQueue.push({ type: 'message', data: text, tempId: tempId });
        updateMessageStatus(tempId, 'queued');
        return;
      }

      // Send to server (plain text)
      socket.emit('message', text, (response) => {
        const latency = Math.round(performance.now() - sendTime);

        if (response && response.status === 'ok') {
          // Update optimistic message with real ID
          const pendingEl = document.getElementById('msg-' + tempId);
          if (pendingEl) {
            pendingEl.id = 'msg-' + response.messageId;
            pendingEl.classList.remove('pending');
            const tickEl = pendingEl.querySelector('.ticks');
            if (tickEl) {
              tickEl.id = 'tick-' + response.messageId;
              tickEl.classList.remove('sending');
              tickEl.classList.add('delivered');
              tickEl.textContent = '‚úì';
            }
          }

          // Track latency
          messageLatency.push(latency);
          if (messageLatency.length > 20) messageLatency.shift();
          const avgLatency = Math.round(messageLatency.reduce((a, b) => a + b, 0) / messageLatency.length);
          log('Message sent in ' + latency + 'ms (avg: ' + avgLatency + 'ms)');

          pendingMessages.delete(tempId);
        } else {
          // Mark as failed
          updateMessageStatus(tempId, 'failed');
          log('Message failed: ' + (response?.message || 'Unknown error'), 'err');
        }
      });

      socket.emit('stopTyping');
      scrollToBottom(true);
    }

    function updateMessageStatus(msgId, status) {
      const tickEl = document.getElementById('tick-' + msgId);
      if (!tickEl) return;

      tickEl.className = 'ticks ' + status;
      switch (status) {
        case 'sending':
          tickEl.textContent = '‚óã';
          break;
        case 'queued':
          tickEl.textContent = '‚ó∑';
          break;
        case 'delivered':
          tickEl.textContent = '‚úì';
          break;
        case 'seen':
          tickEl.textContent = '‚úì‚úì';
          break;
        case 'failed':
          tickEl.textContent = '!';
          tickEl.style.color = '#ef4444';
          break;
      }
    }

    // ===== IMAGE HANDLING =====
    document.getElementById('imgBtn').addEventListener('click', () => {
      document.getElementById('fileInput').click();
    });

    document.getElementById('fileInput').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      if (file.size > 3 * 1024 * 1024) {
        alert('Image too large. Max 3MB.');
        return;
      }
      const reader = new FileReader();
      reader.onload = (ev) => {
        pendingImage = ev.target.result;
        document.getElementById('previewImg').src = pendingImage;
        document.getElementById('previewModal').classList.add('show');
      };
      reader.readAsDataURL(file);
      e.target.value = '';
    });

    document.getElementById('cancelImg').addEventListener('click', () => {
      document.getElementById('previewModal').classList.remove('show');
      pendingImage = null;
    });

    document.getElementById('confirmImg').addEventListener('click', () => {
      if (!pendingImage) return;

      const tempId = 'temp-img-' + Date.now();
      const timestamp = new Date().toISOString();
      const sendTime = performance.now();

      // Show optimistic image immediately
      const optimisticData = {
        id: tempId,
        type: 'image',
        username: myName,
        senderId: myId,
        imageData: pendingImage,
        timestamp: timestamp
      };

      addMessage(optimisticData, 'mine', false, true);

      // Compress image if too large
      const imageToSend = pendingImage.length > 500000 ? compressImage(pendingImage) : Promise.resolve(pendingImage);

      imageToSend.then(compressedImage => {
        socket.emit('imageMessage', compressedImage || pendingImage, (response) => {
          const latency = Math.round(performance.now() - sendTime);

          if (response && response.status === 'ok') {
            const pendingEl = document.getElementById('msg-' + tempId);
            if (pendingEl) {
              pendingEl.id = 'msg-' + response.messageId;
              pendingEl.classList.remove('pending');
              const tickEl = pendingEl.querySelector('.ticks');
              if (tickEl) {
                tickEl.id = 'tick-' + response.messageId;
                tickEl.classList.remove('sending');
                tickEl.classList.add('delivered');
                tickEl.textContent = '‚úì';
              }
            }
            log('Image sent in ' + latency + 'ms');
          } else {
            updateMessageStatus(tempId, 'failed');
            log('Image failed: ' + (response?.message || 'Unknown error'), 'err');
          }
        });
      });

      document.getElementById('previewModal').classList.remove('show');
      pendingImage = null;
    });

    // Image compression for faster sending
    function compressImage(dataUrl, maxWidth = 1200, quality = 0.8) {
      return new Promise((resolve) => {
        const img = new Image();
        img.onload = () => {
          const canvas = document.createElement('canvas');
          let width = img.width;
          let height = img.height;

          if (width > maxWidth) {
            height = (height * maxWidth) / width;
            width = maxWidth;
          }

          canvas.width = width;
          canvas.height = height;

          const ctx = canvas.getContext('2d');
          ctx.drawImage(img, 0, 0, width, height);

          const compressed = canvas.toDataURL('image/jpeg', quality);
          log('Image compressed: ' + Math.round(dataUrl.length / 1024) + 'KB ‚Üí ' + Math.round(compressed.length / 1024) + 'KB');
          resolve(compressed);
        };
        img.onerror = () => resolve(null);
        img.src = dataUrl;
      });
    }

    // ===== USER LIST =====
    document.getElementById('userInfo').addEventListener('click', () => {
      renderUserList();
      document.getElementById('userModal').classList.add('show');
    });

    document.getElementById('closeUserModal').addEventListener('click', () => {
      document.getElementById('userModal').classList.remove('show');
    });

    function renderUserList() {
      const list = document.getElementById('userList');
      list.innerHTML = '';

      users.forEach(u => {
        const isMe = u.socketId === myId;
        const isOnline = u.online !== false;

        const div = document.createElement('div');
        div.className = 'user-item' + (isMe ? ' me' : '');

        div.innerHTML = '<span class="name"><span class="' + (isOnline ? 'online-dot' : 'offline-dot') + '"></span>' +
          escapeHtml(u.username) + (isMe ? ' (you)' : '') + '</span>';

        if (!isMe && isOnline) {
          // Create button container for both call types
          const btnContainer = document.createElement('div');
          btnContainer.className = 'call-buttons';

          // Audio call button
          const audioBtn = document.createElement('button');
          audioBtn.className = 'call-btn audio-call';
          audioBtn.textContent = 'üìû';
          audioBtn.title = 'Audio Call';
          audioBtn.onclick = () => {
            document.getElementById('userModal').classList.remove('show');
            startCall(u.socketId, u.username, false); // false = audio only
          };
          btnContainer.appendChild(audioBtn);

          // Video call button
          const videoBtn = document.createElement('button');
          videoBtn.className = 'call-btn video-call';
          videoBtn.textContent = 'üìπ';
          videoBtn.title = 'Video Call';
          videoBtn.onclick = () => {
            document.getElementById('userModal').classList.remove('show');
            startCall(u.socketId, u.username, true); // true = video call
          };
          btnContainer.appendChild(videoBtn);

          div.appendChild(btnContainer);
        } else if (!isOnline && u.lastSeen) {
          const date = new Date(u.lastSeen);
          const timeStr = date.toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });
          const span = document.createElement('span');
          span.style.fontSize = '12px';
          span.style.color = 'var(--text-muted)';
          span.textContent = timeStr;
          div.appendChild(span);
        }
        list.appendChild(div);
      });
    }

    document.getElementById('leaveBtn').addEventListener('click', () => {
      if (confirm('Leave room?')) {
        log('Leaving room...');

        // Stop background keep-alive
        stopChatKeepAlive();

        // Release wake lock
        releaseWakeLock();

        // Disconnect socket to immediately notify others
        socket.disconnect();

        // Clear local storage
        localStorage.removeItem('chatSessionId');
        localStorage.removeItem('chatRoom');
        localStorage.removeItem('chatName');

        // Reset state
        myRoom = '';
        myName = '';
        mySessionId = '';

        location.reload();
      }
    });

    // ===== AUDIO CALL FUNCTIONS =====
    async function startCall(targetId, targetName, withVideo = false) {
      log((withVideo ? 'üìπ' : 'üìû') + ' Starting ' + (withVideo ? 'video' : 'audio') + ' call to ' + targetName);

      callTarget = targetId;
      callTargetName = targetName;
      isVideoCall = withVideo;
      iceQueue = [];
      remoteDescriptionSet = false;
      isCallConnected = false;
      cameraOff = false;

      // CRITICAL: Initialize audio context before getting media
      initAudioContext();

      document.getElementById('callScreen').classList.add('active');

      // Setup UI based on call type
      if (withVideo) {
        // Video call UI
        videoContainer.classList.add('active');
        audioCallContainer.style.display = 'none';
        audioCallControls.style.display = 'none';
        document.getElementById('videoCallName').textContent = targetName;
        document.getElementById('videoOverlayName').textContent = targetName;
        document.getElementById('videoCallStatus').textContent = 'Calling...';
        document.getElementById('videoCallTimer').textContent = '00:00';
        remoteVideoPlaceholder.classList.remove('hidden', 'connected');
      } else {
        // Audio call UI
        videoContainer.classList.remove('active');
        audioCallContainer.style.display = 'flex';
        audioCallControls.style.display = 'flex';
        document.getElementById('callName').textContent = targetName;
        document.getElementById('callStatusText').textContent = 'Calling...';
        document.getElementById('callTimer').textContent = '00:00';
        document.getElementById('callAvatar').className = 'call-avatar ringing';
      }

      try {
        await getMedia(withVideo);
        await createPC();

        // Add tracks to peer connection
        localStream.getTracks().forEach(track => {
          log('Adding local track: ' + track.kind + ' enabled=' + track.enabled);
          pc.addTrack(track, localStream);
        });

        // Show local video preview for video calls
        if (withVideo && localStream) {
          localVideoEl.srcObject = localStream;
          localVideoWrapper.classList.remove('camera-off');
        }

        // Create and set local description
        const offer = await pc.createOffer({
          offerToReceiveAudio: true,
          offerToReceiveVideo: withVideo,
          voiceActivityDetection: true
        });

        // Apply low-bandwidth optimizations to SDP
        const modifiedSdp = sdpMunge(offer.sdp);
        await pc.setLocalDescription({ type: offer.type, sdp: modifiedSdp });
        log('Local description set (offer)');

        socket.emit('callUser', {
          targetId: targetId,
          offer: pc.localDescription,
          callerName: myName,
          isVideo: withVideo
        });

        // Start background keep-alive
        startKeepAlive();

      } catch (e) {
        log('Call error: ' + e.message, 'err');
        alert('Failed to start call: ' + e.message);
        cleanupCall();
      }
    }

    // ===== HD AUDIO SDP OPTIMIZATION =====
    // Optimizes Opus codec for maximum voice clarity
    function sdpMunge(sdp) {
      if (!sdp) return sdp;

      // Find Opus codec payload type (usually 111)
      const opusMatch = sdp.match(/a=rtpmap:(\d+) opus\/48000/i);
      if (!opusMatch) {
        log('‚ö†Ô∏è Opus codec not found in SDP', 'warn');
        return sdp;
      }

      const opusPayloadType = opusMatch[1];
      log('Found Opus codec with payload type: ' + opusPayloadType);

      // HD Voice settings for maximum clarity
      const hdSettings = [
        'maxaveragebitrate=48000',    // 48kbps for HD voice (was 32kbps)
        'maxplaybackrate=48000',       // Full 48kHz playback
        'useinbandfec=1',              // Enable Forward Error Correction
        'usedtx=0',                    // DISABLE DTX for clearer audio (no choppy silences)
        'stereo=0',                    // Mono for voice (more efficient)
        'sprop-stereo=0',              // Confirm mono
        'cbr=1',                       // Constant bitrate for consistent quality
        'ptime=20',                    // 20ms frames for low latency
        'minptime=10',                 // Allow smaller frames
        'maxptime=40'                  // Cap at 40ms for quality
      ].join(';');

      // Find existing fmtp line for Opus
      const fmtpRegex = new RegExp('a=fmtp:' + opusPayloadType + '\\s+([^\\r\\n]+)', 'i');
      const fmtpMatch = sdp.match(fmtpRegex);

      if (fmtpMatch) {
        // Update existing fmtp line, preserving some original settings
        let existingParams = fmtpMatch[1];

        // Remove conflicting parameters
        existingParams = existingParams.replace(/maxaveragebitrate=\d+;?/gi, '');
        existingParams = existingParams.replace(/maxplaybackrate=\d+;?/gi, '');
        existingParams = existingParams.replace(/useinbandfec=\d+;?/gi, '');
        existingParams = existingParams.replace(/usedtx=\d+;?/gi, '');
        existingParams = existingParams.replace(/stereo=\d+;?/gi, '');
        existingParams = existingParams.replace(/cbr=\d+;?/gi, '');
        existingParams = existingParams.replace(/ptime=\d+;?/gi, '');

        // Clean up any trailing/leading semicolons
        existingParams = existingParams.replace(/^;+|;+$/g, '').replace(/;+/g, ';');

        // Combine with HD settings
        const newParams = existingParams ? existingParams + ';' + hdSettings : hdSettings;
        sdp = sdp.replace(fmtpRegex, 'a=fmtp:' + opusPayloadType + ' ' + newParams);
        log('‚úÖ SDP optimized for HD voice: 48kbps, FEC=on, DTX=off, CBR=on');
      } else {
        // Add new fmtp line after rtpmap
        const rtpmapLine = 'a=rtpmap:' + opusPayloadType + ' opus/48000/2';
        const newFmtpLine = 'a=fmtp:' + opusPayloadType + ' ' + hdSettings;
        sdp = sdp.replace(rtpmapLine, rtpmapLine + '\r\n' + newFmtpLine);
        log('‚úÖ Added HD voice fmtp line: 48kbps, FEC=on, DTX=off, CBR=on');
      }

      // ===== VIDEO OPTIMIZATION (if video call) =====
      if (isVideoCall) {
        log('Optimizing video codec settings...');

        // 1. Prefer VP9 over VP8 and H.264 (better quality/bandwidth ratio)
        sdp = preferVideoCodec(sdp, 'VP9');

        // 2. Set video bitrate constraints (500kbps min, 2.5Mbps max, 1.2Mbps start)
        sdp = setVideoBitrate(sdp, 500, 2500, 1200);

        // 3. Enable VP9 scalable video coding for better network adaptation
        sdp = enableVP9SVC(sdp);

        log('‚úÖ Video SDP optimized: VP9 preferred, bitrate 500-2500kbps, SVC enabled');
      }

      return sdp;
    }

    // ===== VIDEO CODEC OPTIMIZATION HELPERS =====
    // Helper: Prefer specific video codec
    function preferVideoCodec(sdp, codecName) {
      const codecMap = {
        'VP9': 'VP9',
        'VP8': 'VP8',
        'H264': 'H264',
        'H.264': 'H264'
      };

      const codec = codecMap[codecName] || codecName;
      const codecRegex = new RegExp('a=rtpmap:(\\d+) ' + codec + '/\\d+', 'i');
      const match = sdp.match(codecRegex);

      if (!match) {
        log('Codec ' + codec + ' not found, leaving SDP unchanged', 'warn');
        return sdp;
      }

      const codecPayload = match[1];
      log('Preferring ' + codec + ' (payload ' + codecPayload + ')');

      // Re-order m=video line to prefer this codec
      const lines = sdp.split('\r\n');
      let videoMLineIndex = -1;

      for (let i = 0; i < lines.length; i++) {
        if (lines[i].startsWith('m=video')) {
          videoMLineIndex = i;
          break;
        }
      }

      if (videoMLineIndex === -1) return sdp;

      const mLine = lines[videoMLineIndex];
      const elements = mLine.split(' ');

      if (elements.length < 4) return sdp;

      // Extract existing payload types
      const payloads = elements.slice(3);

      // Move preferred codec to front
      const preferredIndex = payloads.indexOf(codecPayload);
      if (preferredIndex !== -1) {
        payloads.splice(preferredIndex, 1);
        payloads.unshift(codecPayload);
      }

      // Reconstruct m= line
      lines[videoMLineIndex] = elements.slice(0, 3).join(' ') + ' ' + payloads.join(' ');

      return lines.join('\r\n');
    }

    // Helper: Set video bitrate constraints
    function setVideoBitrate(sdp, minKbps, maxKbps, startKbps) {
      // Add b=AS (Application-Specific maximum bitrate) line for video
      let lines = sdp.split('\r\n');
      let videoMLineIndex = -1;

      for (let i = 0; i < lines.length; i++) {
        if (lines[i].startsWith('m=video')) {
          videoMLineIndex = i;
          break;
        }
      }

      if (videoMLineIndex === -1) return sdp;

      // Remove existing b=AS lines for video
      let insertIndex = videoMLineIndex + 1;
      while (insertIndex < lines.length && !lines[insertIndex].startsWith('m=')) {
        if (lines[insertIndex].startsWith('b=AS:') || lines[insertIndex].startsWith('b=TIAS:')) {
          lines.splice(insertIndex, 1);
        } else {
          insertIndex++;
        }
      }

      // Insert new bandwidth lines (AS = Application Specific, TIAS = Transport Independent Application Specific)
      const asLine = 'b=AS:' + maxKbps;  // Maximum bitrate
      const tiasLine = 'b=TIAS:' + (maxKbps * 1000);  // Same in bits/sec
      lines.splice(videoMLineIndex + 1, 0, asLine, tiasLine);

      log('Video bitrate set: ' + minKbps + '-' + maxKbps + 'kbps (start: ' + startKbps + 'kbps)');

      return lines.join('\r\n');
    }

    // Helper: Enable VP9 Scalable Video Coding
    function enableVP9SVC(sdp) {
      const vp9Match = sdp.match(/a=rtpmap:(\d+) VP9\/\d+/i);
      if (!vp9Match) return sdp;

      const vp9Payload = vp9Match[1];

      // Check if fmtp line exists for VP9
      const fmtpRegex = new RegExp('a=fmtp:' + vp9Payload + '\\s+([^\\r\\n]+)', 'i');
      const fmtpMatch = sdp.match(fmtpRegex);

      // SVC parameters for VP9
      const svcParams = 'scalability-mode=L3T3';  // 3 spatial layers, 3 temporal layers

      if (fmtpMatch) {
        // Append to existing fmtp
        const newFmtp = 'a=fmtp:' + vp9Payload + ' ' + fmtpMatch[1] + ';' + svcParams;
        sdp = sdp.replace(fmtpRegex, newFmtp);
      } else {
        // Add new fmtp line after rtpmap
        const rtpmapLine = 'a=rtpmap:' + vp9Payload + ' VP9/90000';
        const newFmtpLine = 'a=fmtp:' + vp9Payload + ' ' + svcParams;
        sdp = sdp.replace(rtpmapLine, rtpmapLine + '\r\n' + newFmtpLine);
      }

      log('VP9 SVC enabled (L3T3)');
      return sdp;
    }

    async function getMedia(withVideo = false) {
      log('Requesting ' + (withVideo ? 'camera & microphone' : 'microphone') + ' access...');

      // Detect platform
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
      const isAndroid = /Android/.test(navigator.userAgent);

      // Audio constraints
      const advancedAudioConstraints = {
        echoCancellation: { ideal: true },
        noiseSuppression: { ideal: true },
        autoGainControl: { ideal: true },
        googEchoCancellation: { ideal: true },
        googAutoGainControl: { ideal: true },
        googNoiseSuppression: { ideal: true },
        googHighpassFilter: { ideal: true },
        googTypingNoiseDetection: { ideal: true },
        channelCount: { ideal: 1 },
        sampleRate: { ideal: 48000 },
        sampleSize: { ideal: 16 }
      };

      const simpleAudioConstraints = {
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true
      };

      // Video constraints
      const videoConstraints = withVideo ? {
        facingMode: facingMode,
        width: { ideal: 1280, max: 1920 },
        height: { ideal: 720, max: 1080 },
        frameRate: { ideal: 30, max: 30 }
      } : false;

      try {
        localStream = await navigator.mediaDevices.getUserMedia({
          video: videoConstraints,
          audio: isIOS ? simpleAudioConstraints : advancedAudioConstraints
        });

        const audioTracks = localStream.getAudioTracks();
        const videoTracks = localStream.getVideoTracks();
        log('Media access granted. Audio tracks: ' + audioTracks.length + ', Video tracks: ' + videoTracks.length);

        if (audioTracks.length > 0) {
          const settings = audioTracks[0].getSettings();
          log('Audio settings: ' + JSON.stringify(settings));
        }

        if (videoTracks.length > 0) {
          const settings = videoTracks[0].getSettings();
          log('Video settings: ' + settings.width + 'x' + settings.height + '@' + settings.frameRate + 'fps');
        }

        log(`Platform: ${isIOS ? 'iOS' : isAndroid ? 'Android' : 'Desktop'}`);
        return localStream;

      } catch (e) {
        log('Media error with primary constraints: ' + e.message, 'warn');

        // Fallback to simple constraints
        try {
          log('Trying fallback constraints...');
          localStream = await navigator.mediaDevices.getUserMedia({
            video: withVideo ? true : false,
            audio: true
          });

          log('Fallback media access granted');
          return localStream;
        } catch (e2) {
          log('Media error: ' + e2.message, 'err');
          if (withVideo) {
            throw new Error('Camera/Microphone access denied. Please allow access.');
          } else {
            throw new Error('Microphone access denied. Please allow microphone access.');
          }
        }
      }
    }

    // Keep getAudio for backward compatibility
    async function getAudio() {
      return getMedia(false);
    }

    async function createPC() {
      log('Creating peer connection...');

      if (!iceServers) {
        iceServers = getDefaultIceServers();
      }

      const config = {
        iceServers: iceServers.iceServers,
        // Support 'relay' mode for restrictive networks (forces TURN usage)
        iceTransportPolicy: iceServers.iceTransportPolicy || 'all',
        bundlePolicy: 'max-bundle',
        rtcpMuxPolicy: 'require',
        sdpSemantics: 'unified-plan',
        iceCandidatePoolSize: 4 // Pre-fetch candidates for faster connection
      };

      pc = new RTCPeerConnection(config);
      remoteStream = new MediaStream();

      // NOTE: We do NOT call addTransceiver here - addTrack() creates one automatically
      // Having duplicate transceivers can cause negotiation issues

      // Handle incoming tracks - supports both audio and video
      pc.ontrack = (event) => {
        log('üîä Received remote track: ' + event.track.kind + ', readyState: ' + event.track.readyState);

        if (event.track.kind === 'audio') {
          // CRITICAL: Use event.streams[0] if available (more reliable)
          if (event.streams && event.streams[0]) {
            remoteAudioEl.srcObject = event.streams[0];
            log('Using event.streams[0] for audio');
          } else {
            // Fallback: Add track to our remoteStream
            remoteStream.addTrack(event.track);
            remoteAudioEl.srcObject = remoteStream;
            log('Using manual remoteStream for audio');
          }

          remoteAudioEl.volume = 1.0;
          remoteAudioEl.muted = false;

          // Ensure audio plays
          playRemoteAudio();

          // Monitor track state
          event.track.onended = () => {
            log('Remote audio track ended', 'warn');
          };

          event.track.onmute = () => {
            log('Remote audio track muted', 'warn');
          };

          event.track.onunmute = () => {
            log('Remote audio track unmuted');
          };
        }

        // Handle video track
        if (event.track.kind === 'video') {
          log('üìπ Video track received');

          if (event.streams && event.streams[0]) {
            remoteVideoEl.srcObject = event.streams[0];
          } else {
            remoteStream.addTrack(event.track);
            remoteVideoEl.srcObject = remoteStream;
          }

          // Hide placeholder, show actual video
          remoteVideoPlaceholder.classList.add('hidden');

          // Handle video track events
          event.track.onended = () => {
            log('Remote video track ended', 'warn');
            remoteVideoPlaceholder.classList.remove('hidden');
          };

          event.track.onmute = () => {
            log('Remote video track muted (camera off)', 'warn');
            remoteVideoPlaceholder.classList.remove('hidden');
            remoteVideoPlaceholder.classList.add('connected');
          };

          event.track.onunmute = () => {
            log('Remote video track unmuted (camera on)');
            remoteVideoPlaceholder.classList.add('hidden');
          };
        }
      };

      pc.onicecandidate = (event) => {
        if (event.candidate && callTarget) {
          log('Sending ICE candidate: ' + event.candidate.candidate.slice(0, 50));
          socket.emit('iceCandidate', {
            targetId: callTarget,
            candidate: event.candidate
          });
        } else if (!event.candidate) {
          log('ICE gathering complete');
        }
      };

      pc.oniceconnectionstatechange = () => {
        log('ICE state: ' + pc.iceConnectionState);
        updateAudioDebug();

        switch (pc.iceConnectionState) {
          case 'checking':
            updateCallStatus('Connecting...');
            // Set a timeout - if we're still checking after 30 seconds, something is wrong
            if (!window.iceCheckingTimeout) {
              window.iceCheckingTimeout = setTimeout(() => {
                if (pc && pc.iceConnectionState === 'checking') {
                  log('ICE connection timeout - stuck in checking state', 'err');
                  updateCallStatus('Connection failed - retrying...');
                  pc.restartIce();
                }
              }, 30000);
            }
            break;
          case 'connected':
          case 'completed':
            // Clear the timeout if we connected successfully
            if (window.iceCheckingTimeout) {
              clearTimeout(window.iceCheckingTimeout);
              window.iceCheckingTimeout = null;
            }
            setCallConnected();
            break;
          case 'failed':
            log('ICE failed, restarting...', 'warn');
            updateCallStatus('Reconnecting...');
            pc.restartIce();
            break;
          case 'disconnected':
            log('Connection interrupted, attempting auto-reconnect...');
            updateCallStatus('Reconnecting...');

            // Try automatic recovery by restarting ICE immediately
            if (pc) pc.restartIce();

            // If it doesn't recover quickly, show the manual button
            setTimeout(() => {
              if (pc && pc.connectionState !== 'connected') {
                updateCallStatus('Connection unstable...');
                document.getElementById('reconnectBtn').style.display = 'block';
              }
            }, 3000);
            break;
        }
      };

      // Reconnect button handler
      document.getElementById('reconnectBtn').onclick = () => {
        log('Manual ICE restart requested');
        document.getElementById('reconnectBtn').style.display = 'none';
        updateCallStatus('Reconnecting...');
        if (pc) pc.restartIce();
      };

      pc.onconnectionstatechange = () => {
        log('Connection state: ' + pc.connectionState);
        updateAudioDebug();

        if (pc.connectionState === 'connected') {
          setCallConnected();
        } else if (pc.connectionState === 'failed') {
          // Try auto-reconnection first
          attemptCallReconnection();
        } else if (pc.connectionState === 'disconnected') {
          // Trigger auto-reconnect on disconnect
          setTimeout(() => {
            if (pc && pc.connectionState === 'disconnected') {
              attemptCallReconnection();
            }
          }, 2000);
        }
      };

      pc.onsignalingstatechange = () => {
        log('Signaling state: ' + pc.signalingState);
      };

      pc.onicegatheringstatechange = () => {
        log('ICE gathering state: ' + pc.iceGatheringState);
      };
    }

    // ===== PLAY REMOTE AUDIO - CRITICAL FUNCTION =====
    async function playRemoteAudio() {
      log('Attempting to play remote audio...');

      // Detect platform for specific workarounds
      const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
      const isAndroid = /Android/.test(navigator.userAgent);
      const isSafari = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);

      log(`Platform: ${isIOS ? 'iOS' : isAndroid ? 'Android' : 'Desktop'}, Safari: ${isSafari}`);

      // Make sure audio context is running - iOS requirement
      if (audioContext && audioContext.state === 'suspended') {
        try {
          await audioContext.resume();
          log('AudioContext resumed for playback');
        } catch (e) {
          log('Could not resume AudioContext: ' + e.message, 'warn');
        }
      }

      // Configure audio element - iOS REQUIRES these attributes
      remoteAudioEl.volume = 1.0;
      remoteAudioEl.muted = false;
      remoteAudioEl.playsInline = true;
      remoteAudioEl.setAttribute('playsinline', '');
      remoteAudioEl.setAttribute('webkit-playsinline', ''); // Legacy iOS

      // iOS Safari specific: Need to "warm up" the audio element
      if (isIOS || isSafari) {
        try {
          // Create and play a silent audio to unlock audio on iOS
          remoteAudioEl.src = 'data:audio/wav;base64,UklGRnoGAABXQVZFZm10IBAAAAABAAEAQB8AAEAfAAABAAgAZGF0YQoGAACBhYqFbF1fdH2Onr6xk4d9eXx5enN4gY2UsZaIgXt6enh1d36KmKudhHt3fHx7d3d+ipasnIN8eXt9fHd3foqXrJ2EfHh6fH17d3mIlq+gh3x3eXx+fXd2fo2asZyEfHd5fH99d3Z+jJqynYV8d3l8f393dn6MmrKehXx3eXx/f3d2foyasp6FfHd5fH9/d3Z+jJqynoV8d3l8f393dn6MmrKehXx3eXx/f3d2foyasp6FfHd5fH9/d3Z+jJqy';
          await remoteAudioEl.play();
          remoteAudioEl.pause();
          log('iOS audio warmup complete');
        } catch (e) {
          log('iOS audio warmup failed (normal if no user gesture): ' + e.message, 'warn');
        }

        // Reset to actual stream
        if (remoteStream && remoteStream.getAudioTracks().length > 0) {
          remoteAudioEl.srcObject = remoteStream;
        }
      }

      // NOTE: We'll set audio output AFTER play() succeeds to avoid blocking

      try {
        await remoteAudioEl.play();
        log('‚úÖ Remote audio playing successfully!');

        // Set audio output AFTER play succeeds
        setAudioOutput(false).catch(e => log('Audio output setting failed: ' + e.message, 'warn'));

        setCallConnected();
      } catch (err) {
        log('Audio autoplay blocked: ' + err.message, 'warn');
        updateCallStatus('Tap screen to enable audio');

        // Add click handlers to enable audio
        const enableAudio = async () => {
          try {
            if (audioContext && audioContext.state === 'suspended') {
              await audioContext.resume();
            }

            // For iOS, unmute first then play
            if (isIOS) {
              remoteAudioEl.muted = true;
              await remoteAudioEl.play();
              remoteAudioEl.muted = false;
            } else {
              await remoteAudioEl.play();
            }

            log('‚úÖ Audio enabled after user interaction');
            setCallConnected();
            document.getElementById('callScreen').removeEventListener('click', enableAudio);
            document.getElementById('callScreen').removeEventListener('touchstart', enableAudio);
          } catch (e) {
            log('Still cannot play audio: ' + e.message, 'err');
          }
        };

        document.getElementById('callScreen').addEventListener('click', enableAudio);
        document.getElementById('callScreen').addEventListener('touchstart', enableAudio, { passive: true });
      }
    }

    // ===== AUDIO OUTPUT CONTROL (EARPIECE/SPEAKER/HEADPHONES) =====
    let currentAudioDevice = 'default';
    let headphonesConnected = false;

    async function getAudioOutputDevices() {
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        audioOutputDevices = devices.filter(d => d.kind === 'audiooutput');
        log('Audio outputs found: ' + audioOutputDevices.length);
        audioOutputDevices.forEach(d => log('  - ' + d.label + ' (' + d.deviceId + ')'));

        // Detect headphones
        headphonesConnected = audioOutputDevices.some(d =>
          d.label.toLowerCase().includes('headphone') ||
          d.label.toLowerCase().includes('headset') ||
          d.label.toLowerCase().includes('airpod') ||
          d.label.toLowerCase().includes('earbud') ||
          d.label.toLowerCase().includes('bluetooth')
        );

        if (headphonesConnected) {
          log('üéß Headphones detected!');
        }

        return audioOutputDevices;
      } catch (e) {
        log('Cannot enumerate devices: ' + e.message, 'warn');
        return [];
      }
    }

    // Listen for device changes (headphone connect/disconnect)
    if (navigator.mediaDevices && navigator.mediaDevices.addEventListener) {
      navigator.mediaDevices.addEventListener('devicechange', async () => {
        log('Audio device change detected');
        const devices = await getAudioOutputDevices();

        // If in a call, automatically switch to headphones if connected
        if (isCallConnected && remoteAudioEl.srcObject) {
          await autoSelectAudioOutput();
        }
      });
    }

    async function autoSelectAudioOutput() {
      const devices = await getAudioOutputDevices();

      // Priority: Headphones > Earpiece > Speaker
      let targetDevice = null;

      // First, check for headphones/bluetooth
      targetDevice = devices.find(d =>
        d.label.toLowerCase().includes('headphone') ||
        d.label.toLowerCase().includes('headset') ||
        d.label.toLowerCase().includes('airpod') ||
        d.label.toLowerCase().includes('earbud') ||
        d.label.toLowerCase().includes('bluetooth')
      );

      if (targetDevice) {
        await setAudioOutputDevice(targetDevice);
        updateSpeakerButtonUI('headphones');
        log('üéß Auto-switched to headphones: ' + targetDevice.label);
        return;
      }

      // If no headphones, use earpiece for calls (not speaker)
      if (!speakerMode) {
        targetDevice = devices.find(d =>
          d.label.toLowerCase().includes('earpiece') ||
          d.label.toLowerCase().includes('handset') ||
          d.label.toLowerCase().includes('receiver')
        );

        if (targetDevice) {
          await setAudioOutputDevice(targetDevice);
          updateSpeakerButtonUI('earpiece');
          return;
        }
      }

      // Fallback to default
      updateSpeakerButtonUI(speakerMode ? 'speaker' : 'earpiece');
    }

    async function setAudioOutputDevice(device) {
      if (typeof remoteAudioEl.setSinkId === 'function') {
        try {
          await remoteAudioEl.setSinkId(device.deviceId);
          currentAudioDevice = device.deviceId;
          log('Audio output set to: ' + device.label);
          return true;
        } catch (e) {
          log('setSinkId error: ' + e.message, 'warn');
        }
      }
      return false;
    }

    function updateSpeakerButtonUI(mode) {
      const speakerBtn = document.getElementById('speakerBtn');
      speakerBtn.classList.remove('active');

      switch (mode) {
        case 'headphones':
          speakerBtn.textContent = 'üéß';
          speakerBtn.style.background = '#3b82f6'; // Blue for headphones
          break;
        case 'speaker':
          speakerBtn.classList.add('active');
          speakerBtn.textContent = 'üîä';
          speakerBtn.style.background = '#22c55e'; // Green for speaker
          break;
        case 'earpiece':
        default:
          speakerBtn.textContent = 'üì±';
          speakerBtn.style.background = '#8b5cf6'; // Purple for earpiece
          break;
      }
    }

    async function setAudioOutput(useSpeaker) {
      speakerMode = useSpeaker;
      log('Setting audio output: ' + (useSpeaker ? 'SPEAKER' : 'EARPIECE/HEADPHONES'));

      // If headphones are connected, they take priority
      if (headphonesConnected && !useSpeaker) {
        await autoSelectAudioOutput();
        return true;
      }

      // Update UI based on mode
      updateSpeakerButtonUI(useSpeaker ? 'speaker' : 'earpiece');

      // Method 1: Use setSinkId API (Chrome, Edge, some Android browsers)
      if (typeof remoteAudioEl.setSinkId === 'function') {
        try {
          const devices = await getAudioOutputDevices();

          if (devices.length > 0) {
            // Find appropriate device
            let targetDevice = null;

            if (useSpeaker) {
              // Look for speaker
              targetDevice = devices.find(d =>
                d.label.toLowerCase().includes('speaker') ||
                d.label.toLowerCase().includes('speakerphone')
              );
            } else {
              // Look for headphones first, then earpiece
              targetDevice = devices.find(d =>
                d.label.toLowerCase().includes('headphone') ||
                d.label.toLowerCase().includes('headset') ||
                d.label.toLowerCase().includes('airpod') ||
                d.label.toLowerCase().includes('bluetooth')
              );

              if (!targetDevice) {
                // Look for earpiece/handset
                targetDevice = devices.find(d =>
                  d.label.toLowerCase().includes('earpiece') ||
                  d.label.toLowerCase().includes('handset') ||
                  d.label.toLowerCase().includes('receiver')
                );
              }
            }

            // If specific device found, use it
            if (targetDevice) {
              await remoteAudioEl.setSinkId(targetDevice.deviceId);
              currentAudioDevice = targetDevice.deviceId;
              log('Audio output set to: ' + targetDevice.label);

              // Update UI for headphones
              if (targetDevice.label.toLowerCase().includes('headphone') ||
                targetDevice.label.toLowerCase().includes('headset') ||
                targetDevice.label.toLowerCase().includes('airpod') ||
                targetDevice.label.toLowerCase().includes('bluetooth')) {
                updateSpeakerButtonUI('headphones');
              }
              return true;
            }

            // Fallback: use default device for speaker, first non-default for earpiece
            if (useSpeaker) {
              await remoteAudioEl.setSinkId('default');
              log('Audio output set to default (speaker)');
            } else if (devices.length > 1) {
              // Try non-default device for earpiece
              const nonDefault = devices.find(d => d.deviceId !== 'default');
              if (nonDefault) {
                await remoteAudioEl.setSinkId(nonDefault.deviceId);
                log('Audio output set to: ' + nonDefault.label);
              }
            }
            return true;
          }
        } catch (e) {
          log('setSinkId error: ' + e.message, 'warn');
        }
      }

      // Method 2: Volume-based workaround - REMOVED, always use max volume
      remoteAudioEl.volume = 1.0;
      log('Audio volume set to 100%');

      // Method 3: For iOS Safari - AudioContext routing hint
      if (audioContext && !useSpeaker) {
        try {
          // This doesn't actually route audio, but resuming the context might help iOS
          // decide this is a call.
          if (audioContext.state === 'suspended') await audioContext.resume();
        } catch (e) {
          log('AudioContext resume failed: ' + e.message, 'warn');
        }
      }

      return false;
    }

    function addIceCandidate(candidate) {
      if (!pc || pc.signalingState === 'closed') {
        log('Cannot add ICE candidate - PC closed', 'warn');
        return;
      }

      pc.addIceCandidate(new RTCIceCandidate(candidate))
        .then(() => log('ICE candidate added successfully'))
        .catch(e => log('ICE candidate error: ' + e.message, 'err'));
    }

    function processIceQueue() {
      if (iceQueue.length > 0) {
        log('Processing ' + iceQueue.length + ' queued ICE candidates');
        while (iceQueue.length > 0) {
          addIceCandidate(iceQueue.shift());
        }
      } else {
        log('ICE queue is empty, no candidates to process');
      }
    }

    // Helper to update call status text for both audio and video calls
    function updateCallStatus(text) {
      document.getElementById('callStatusText').textContent = text;
      document.getElementById('videoCallStatus').textContent = text;
    }

    function setCallConnected() {
      if (isCallConnected) return;
      isCallConnected = true;

      // Update UI based on call type
      if (isVideoCall) {
        document.getElementById('videoCallStatus').textContent = 'Connected';
        remoteVideoPlaceholder.classList.add('connected');
      } else {
        document.getElementById('callStatusText').textContent = 'Connected';
        document.getElementById('callAvatar').className = 'call-avatar connected';
      }

      startCallTimer();
      log('‚úÖ ' + (isVideoCall ? 'Video' : 'Audio') + ' call connected!');
      updateAudioDebug();

      // Start audio level meters
      startAudioMeters();

      // Start comprehensive WebRTC stats monitoring
      startWebRTCStatsMonitoring();

      // Reset reconnection attempts
      reconnectAttempts = 0;
    }

    // ===== WEBRTC STATS MONITORING & BANDWIDTH ADAPTATION =====
    let statsMonitoringInterval = null;
    let callStats = {
      rtt: 0,
      jitter: 0,
      packetLoss: 0,
      bitrate: { audio: 0, video: 0 },
      timestamp: Date.now()
    };

    function startWebRTCStatsMonitoring() {
      if (statsMonitoringInterval) clearInterval(statsMonitoringInterval);

      // Monitor stats every 2 seconds
      statsMonitoringInterval = setInterval(async () => {
        if (!pc || pc.connectionState !== 'connected') return;

        try {
          const stats = await pc.getStats();
          await processWebRTCStats(stats);
        } catch (e) {
          log('Stats error: ' + e.message, 'err');
        }
      }, 2000);

      log('Started WebRTC stats monitoring');
    }

    async function processWebRTCStats(stats) {
      let inboundAudio = null;
      let inboundVideo = null;
      let candidatePair = null;

      stats.forEach(report => {
        // Get inbound RTP stats
        if (report.type === 'inbound-rtp' && report.kind === 'audio') {
          inboundAudio = report;
        } else if (report.type === 'inbound-rtp' && report.kind === 'video') {
          inboundVideo = report;
        }
        // Get ICE candidate pair stats (for RTT)
        else if (report.type === 'candidate-pair' && report.state === 'succeeded') {
          candidatePair = report;
        }
      });

      // Calculate RTT (Round Trip Time)
      if (candidatePair && candidatePair.currentRoundTripTime !== undefined) {
        callStats.rtt = Math.round(candidatePair.currentRoundTripTime * 1000); // Convert to ms
      }

      // Calculate packet loss and jitter for audio
      if (inboundAudio) {
        const packetsReceived = inboundAudio.packetsReceived || 0;
        const packetsLost = inboundAudio.packetsLost || 0;
        const totalPackets = packetsReceived + packetsLost;

        if (totalPackets > 0) {
          callStats.packetLoss = ((packetsLost / totalPackets) * 100).toFixed(2);
        }

        callStats.jitter = inboundAudio.jitter ? Math.round(inboundAudio.jitter * 1000) : 0;
        callStats.bitrate.audio = calculateBitrate(inboundAudio);
      }

      // Calculate bitrate for video
      if (inboundVideo) {
        callStats.bitrate.video = calculateBitrate(inboundVideo);
      }

      // Update network quality indicator based on stats
      updateNetworkQualityFromStats();

      // Adaptive bandwidth control
      adaptBandwidth();

      // Update debug display if visible
      updateAudioDebug();
    }

    function calculateBitrate(report) {
      const now = Date.now();
      const bytes = report.bytesReceived || 0;

      if (!report._prevBytes || !report._prevTime) {
        report._prevBytes = bytes;
        report._prevTime = now;
        return 0;
      }

      const bitrate = Math.round(((bytes - report._prevBytes) * 8) / ((now - report._prevTime) / 1000) / 1000); // kbps

      report._prevBytes = bytes;
      report._prevTime = now;

      return bitrate;
    }

    function updateNetworkQualityFromStats() {
      const networkEl = document.querySelector('.network-quality');
      if (!networkEl) return;

      // Determine quality based on RTT, packet loss, and jitter
      let quality = 'excellent';

      if (callStats.rtt > 300 || callStats.packetLoss > 5 || callStats.jitter > 50) {
        quality = 'poor';
      } else if (callStats.rtt > 150 || callStats.packetLoss > 2 || callStats.jitter > 30) {
        quality = 'fair';
      } else if (callStats.rtt > 80 || callStats.packetLoss > 1 || callStats.jitter > 20) {
        quality = 'good';
      }

      // Update UI
      networkEl.className = 'network-quality ' + (quality === 'poor' ? 'poor' : quality === 'fair' ? 'fair' : '');

      log('Network quality: ' + quality + ' (RTT: ' + callStats.rtt + 'ms, Loss: ' + callStats.packetLoss + '%, Jitter: ' + callStats.jitter + 'ms)');
    }

    function adaptBandwidth() {
      if (!isVideoCall || !pc) return;

      // Auto-adjust video quality based on packet loss and RTT
      const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
      if (!sender) return;

      const params = sender.getParameters();
      if (!params.encodings || params.encodings.length === 0) return;

      const encoding = params.encodings[0];

      // Adapt based on network quality
      if (callStats.packetLoss > 5 || callStats.rtt > 300) {
        // Poor network: reduce to low quality
        encoding.maxBitrate = 500000; // 500kbps
        encoding.scaleResolutionDownBy = 4; // Quarter resolution
        log('‚ö†Ô∏è Poor network detected, reducing video quality to LOW');
      } else if (callStats.packetLoss > 2 || callStats.rtt > 150) {
        // Fair network: medium quality
        encoding.maxBitrate = 1200000; // 1.2Mbps
        encoding.scaleResolutionDownBy = 2; // Half resolution
        log('üìä Fair network, setting video quality to MEDIUM');
      } else {
        // Good network: high quality
        encoding.maxBitrate = 2500000; // 2.5Mbps
        encoding.scaleResolutionDownBy = 1; // Full resolution
        log('‚úÖ Good network, using HIGH quality video');
      }

      sender.setParameters(params).catch(e => log('Bitrate adaptation error: ' + e.message, 'warn'));
    }

    function stopWebRTCStatsMonitoring() {
      if (statsMonitoringInterval) {
        clearInterval(statsMonitoringInterval);
        statsMonitoringInterval = null;
        log('Stopped WebRTC stats monitoring');
      }
    }

    function startCallTimer() {
      if (callTimer) return;
      callSeconds = 0;
      callTimer = setInterval(() => {
        callSeconds++;
        const mins = Math.floor(callSeconds / 60);
        const secs = callSeconds % 60;
        const timeStr = (mins < 10 ? '0' : '') + mins + ':' + (secs < 10 ? '0' : '') + secs;

        // Update both timers (only one will be visible)
        document.getElementById('callTimer').textContent = timeStr;
        document.getElementById('videoCallTimer').textContent = timeStr;
      }, 1000);
    }

    function stopCallTimer() {
      if (callTimer) {
        clearInterval(callTimer);
        callTimer = null;
      }
      callSeconds = 0;
    }

    // ===== BACKGROUND AUDIO KEEP-ALIVE =====
    let silentOscillator = null;

    function startKeepAlive() {
      if (keepAliveInterval) clearInterval(keepAliveInterval);

      // CRITICAL: Create silent audio oscillator to keep audio context alive in background
      // This tricks the browser into thinking audio is playing, preventing suspension
      if (audioContext && !silentOscillator) {
        try {
          silentOscillator = audioContext.createOscillator();
          const silentGain = audioContext.createGain();
          silentGain.gain.value = 0.001; // Nearly silent
          silentOscillator.connect(silentGain);
          silentGain.connect(audioContext.destination);
          silentOscillator.start();
          log('Silent audio oscillator started for background');
        } catch (e) {
          log('Could not create silent oscillator: ' + e.message, 'warn');
        }
      }

      // Keep connection alive in background - check more frequently (every 2 seconds)
      keepAliveInterval = setInterval(() => {
        if (pc && isCallConnected) {
          // Re-enable audio track if it got disabled
          if (localStream) {
            const tracks = localStream.getAudioTracks();
            if (tracks.length > 0 && !tracks[0].enabled && !micOff) {
              log('Detected audio track disabled, re-enabling', 'warn');
              tracks[0].enabled = true;
            }
          }

          // Force resume audio context if suspended
          if (audioContext && audioContext.state === 'suspended') {
            audioContext.resume().then(() => {
              log('AudioContext resumed in background');
            }).catch(() => { });
          }

          // Check if audio is still playing
          if (remoteAudioEl.paused && remoteAudioEl.srcObject) {
            log('Remote audio paused, attempting to resume...', 'warn');
            remoteAudioEl.play().catch(() => { });
          }

          // Check WebRTC connection health
          if (pc.iceConnectionState === 'disconnected') {
            log('ICE disconnected in background, restarting...', 'warn');
            pc.restartIce();
          }
        }
      }, 2000); // Check every 2 seconds for faster response

      // Prevent device sleep during call
      requestWakeLock();

      // Show persistent notification on Android to keep app alive
      showCallNotification();
    }

    function stopKeepAlive() {
      if (keepAliveInterval) {
        clearInterval(keepAliveInterval);
        keepAliveInterval = null;
      }

      // Stop silent oscillator
      if (silentOscillator) {
        try {
          silentOscillator.stop();
          silentOscillator.disconnect();
        } catch (e) { }
        silentOscillator = null;
      }

      // Release wake lock
      releaseWakeLock();

      // Clear call notification
      clearCallNotification();

      // Stop audio meters
      stopAudioMeters();

      // Stop both network monitoring functions
      stopNetworkMonitoring();
      stopWebRTCStatsMonitoring();
    }

    // ===== AUDIO LEVEL METERS =====
    let localAnalyser = null;
    let remoteAnalyser = null;
    let audioMeterInterval = null;

    function startAudioMeters() {
      if (!audioContext) return;

      log('Starting audio level meters...');

      // Create analyser for local audio (microphone)
      if (localStream && localStream.getAudioTracks().length > 0) {
        try {
          localAnalyser = audioContext.createAnalyser();
          localAnalyser.fftSize = 256;
          const localSource = audioContext.createMediaStreamSource(localStream);
          localSource.connect(localAnalyser);
        } catch (e) {
          log('Could not create local analyser: ' + e.message, 'warn');
        }
      }

      // Create analyser for remote audio (speaker)
      if (remoteStream && remoteStream.getAudioTracks().length > 0) {
        try {
          remoteAnalyser = audioContext.createAnalyser();
          remoteAnalyser.fftSize = 256;
          const remoteSource = audioContext.createMediaStreamSource(remoteStream);
          remoteSource.connect(remoteAnalyser);
        } catch (e) {
          log('Could not create remote analyser: ' + e.message, 'warn');
        }
      }

      // Update meters at 30fps
      audioMeterInterval = setInterval(updateAudioMeters, 33);
    }

    function stopAudioMeters() {
      if (audioMeterInterval) {
        clearInterval(audioMeterInterval);
        audioMeterInterval = null;
      }
      localAnalyser = null;
      remoteAnalyser = null;

      // Reset meter display
      const localBars = document.querySelectorAll('#localMeter .audio-meter-bar');
      const remoteBars = document.querySelectorAll('#remoteMeter .audio-meter-bar');
      localBars.forEach(bar => bar.style.height = '2px');
      remoteBars.forEach(bar => bar.style.height = '2px');
    }

    function updateAudioMeters() {
      updateMeter(localAnalyser, '#localMeter', micOff);
      updateMeter(remoteAnalyser, '#remoteMeter', speakerOff);
    }

    function updateMeter(analyser, selector, isMuted) {
      const meter = document.querySelector(selector);
      const bars = meter.querySelectorAll('.audio-meter-bar');

      if (isMuted) {
        meter.classList.add('muted');
        bars.forEach(bar => bar.style.height = '2px');
        return;
      }

      meter.classList.remove('muted');

      if (!analyser) {
        bars.forEach(bar => bar.style.height = '2px');
        return;
      }

      const dataArray = new Uint8Array(analyser.frequencyBinCount);
      analyser.getByteFrequencyData(dataArray);

      // Calculate average volume
      let sum = 0;
      for (let i = 0; i < dataArray.length; i++) {
        sum += dataArray[i];
      }
      const average = sum / dataArray.length;
      const normalizedLevel = Math.min(average / 128, 1); // 0-1 range

      // Update bars with varying heights
      bars.forEach((bar, index) => {
        const threshold = (index + 1) / bars.length;
        const height = normalizedLevel >= threshold * 0.8 ?
          (8 + (index * 6) + (normalizedLevel * 10)) : 2;
        bar.style.height = Math.min(height, 40) + 'px';

        // Color coding
        bar.className = 'audio-meter-bar';
        if (index >= 4) bar.classList.add('high');
        else if (index >= 2) bar.classList.add('mid');
        else bar.classList.add('low');
      });
    }

    // ===== NETWORK QUALITY MONITORING =====
    let networkMonitorInterval = null;
    let lastBytesReceived = 0;
    let lastBytesSent = 0;
    let lastPacketsLost = 0;
    let lastPacketsReceived = 0;
    let currentBitrate = 32000; // Start at 32kbps

    function startNetworkMonitoring() {
      if (!pc) return;
      log('Starting network quality monitoring...');

      networkMonitorInterval = setInterval(async () => {
        if (!pc || pc.connectionState === 'closed') return;

        try {
          const stats = await pc.getStats();
          let packetsLost = 0;
          let packetsReceived = 0;
          let bytesReceived = 0;
          let bytesSent = 0;
          let jitter = 0;
          let roundTripTime = 0;
          let audioLevel = 0;

          stats.forEach(report => {
            if (report.type === 'inbound-rtp' && report.kind === 'audio') {
              packetsLost = report.packetsLost || 0;
              packetsReceived = report.packetsReceived || 0;
              bytesReceived = report.bytesReceived || 0;
              jitter = report.jitter || 0;
              audioLevel = report.audioLevel || 0;
            }
            if (report.type === 'outbound-rtp' && report.kind === 'audio') {
              bytesSent = report.bytesSent || 0;
            }
            if (report.type === 'candidate-pair' && report.state === 'succeeded') {
              roundTripTime = report.currentRoundTripTime || 0;
            }
          });

          // Calculate packet loss percentage
          const totalPackets = packetsReceived + packetsLost;
          const lossPercent = totalPackets > 0 ? (packetsLost / totalPackets) * 100 : 0;

          // Calculate bitrate (bytes/second)
          const receiveBitrate = (bytesReceived - lastBytesReceived) * 8;
          const sendBitrate = (bytesSent - lastBytesSent) * 8;

          lastBytesReceived = bytesReceived;
          lastBytesSent = bytesSent;

          // Determine network quality
          let quality = 'good';
          let qualityText = 'Excellent';

          if (lossPercent > 10 || jitter > 0.1 || roundTripTime > 0.3) {
            quality = 'poor';
            qualityText = 'Poor ‚Ä¢ ' + Math.round(lossPercent) + '% loss';
          } else if (lossPercent > 3 || jitter > 0.05 || roundTripTime > 0.15) {
            quality = 'fair';
            qualityText = 'Fair ‚Ä¢ ' + Math.round(roundTripTime * 1000) + 'ms';
          } else {
            qualityText = 'Good ‚Ä¢ ' + Math.round(roundTripTime * 1000) + 'ms';
          }

          // Update UI
          updateNetworkQuality(quality);
          document.getElementById('networkInfo').textContent = qualityText;
          document.getElementById('callStats').textContent =
            `‚Üì ${formatBitrate(receiveBitrate)} ‚Üë ${formatBitrate(sendBitrate)} | RTT: ${Math.round(roundTripTime * 1000)}ms`;

          // Adaptive bitrate
          adjustBitrate(quality, lossPercent);

        } catch (e) {
          log('Stats error: ' + e.message, 'warn');
        }
      }, 1000); // Update every second
    }

    function stopNetworkMonitoring() {
      if (networkMonitorInterval) {
        clearInterval(networkMonitorInterval);
        networkMonitorInterval = null;
      }
      lastBytesReceived = 0;
      lastBytesSent = 0;
    }

    function formatBitrate(bps) {
      if (bps > 1000000) return (bps / 1000000).toFixed(1) + ' Mbps';
      if (bps > 1000) return (bps / 1000).toFixed(0) + ' kbps';
      return bps + ' bps';
    }

    function updateNetworkQuality(quality) {
      const el = document.getElementById('networkQuality');
      el.className = 'network-quality ' + quality;
    }

    // ===== ADAPTIVE BITRATE =====
    async function adjustBitrate(quality, lossPercent) {
      if (!pc) return;

      let targetBitrate = currentBitrate;

      if (quality === 'poor' && currentBitrate > 16000) {
        targetBitrate = 16000; // Drop to 16kbps
        log('Reducing bitrate to 16kbps due to poor network', 'warn');
      } else if (quality === 'fair' && currentBitrate !== 24000) {
        targetBitrate = 24000; // Medium quality
      } else if (quality === 'good' && currentBitrate < 32000) {
        targetBitrate = 32000; // Full quality
      }

      if (targetBitrate !== currentBitrate) {
        currentBitrate = targetBitrate;

        // Apply new bitrate via sender parameters
        const senders = pc.getSenders();
        for (const sender of senders) {
          if (sender.track && sender.track.kind === 'audio') {
            const params = sender.getParameters();
            if (!params.encodings) params.encodings = [{}];
            params.encodings[0].maxBitrate = targetBitrate;
            try {
              await sender.setParameters(params);
              log('Bitrate adjusted to: ' + formatBitrate(targetBitrate));
            } catch (e) {
              log('Could not adjust bitrate: ' + e.message, 'warn');
            }
          }
        }
      }
    }

    // ===== AUTOMATIC CALL RECONNECTION =====
    let reconnectAttempts = 0;
    const maxReconnectAttempts = 5;

    async function attemptCallReconnection() {
      if (!callTarget || !isCallConnected) return;
      if (reconnectAttempts >= maxReconnectAttempts) {
        log('Max reconnection attempts reached', 'err');
        updateCallStatus('Connection lost');
        return;
      }

      reconnectAttempts++;
      log('Attempting call reconnection (' + reconnectAttempts + '/' + maxReconnectAttempts + ')...');
      updateCallStatus('Reconnecting... (' + reconnectAttempts + ')');

      try {
        // First try ICE restart
        if (pc && pc.connectionState !== 'closed') {
          pc.restartIce();

          // Wait for connection to recover
          await new Promise((resolve) => {
            const checkConnection = setInterval(() => {
              if (pc && (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed')) {
                clearInterval(checkConnection);
                resolve();
              }
            }, 500);

            // Timeout after 5 seconds
            setTimeout(() => {
              clearInterval(checkConnection);
              resolve();
            }, 5000);
          });

          if (pc && (pc.iceConnectionState === 'connected' || pc.iceConnectionState === 'completed')) {
            log('Reconnection successful!');
            updateCallStatus('Connected');
            reconnectAttempts = 0;
            return;
          }
        }

        log('ICE restart failed, connection may need manual intervention', 'warn');
        document.getElementById('reconnectBtn').style.display = 'block';

      } catch (e) {
        log('Reconnection error: ' + e.message, 'err');
      }
    }

    // Manual reconnect button handler
    document.getElementById('reconnectBtn').addEventListener('click', async () => {
      log('Manual reconnect requested');
      reconnectAttempts = 0;
      document.getElementById('reconnectBtn').style.display = 'none';
      await attemptCallReconnection();
    });

    async function requestWakeLock() {
      if ('wakeLock' in navigator) {
        try {
          window.wakeLock = await navigator.wakeLock.request('screen');
          log('Wake lock acquired');

          // Re-acquire wake lock if released (e.g., when screen turns off)
          window.wakeLock.addEventListener('release', () => {
            log('Wake lock released, re-acquiring...');
            if (isCallConnected) {
              requestWakeLock();
            }
          });
        } catch (e) {
          log('Wake lock failed: ' + e.message, 'warn');
        }
      }
    }

    function releaseWakeLock() {
      if (window.wakeLock) {
        window.wakeLock.release().then(() => {
          log('Wake lock released');
          window.wakeLock = null;
        }).catch(() => { });
      }
    }

    function showCallNotification() {
      if (!('Notification' in window) || Notification.permission !== 'granted') return;

      // Use Service Worker to show persistent notification
      if ('serviceWorker' in navigator && navigator.serviceWorker.controller) {
        navigator.serviceWorker.controller.postMessage({
          type: 'SHOW_NOTIFICATION',
          payload: {
            title: (isVideoCall ? 'üìπ' : 'üìû') + ' Call in Progress',
            body: (isVideoCall ? 'Video' : 'Audio') + ' call with ' + callTargetName,
            tag: 'ongoing-call',
            data: { type: 'call' }
          }
        });
      }
    }

    function clearCallNotification() {
      if ('serviceWorker' in navigator && navigator.serviceWorker.registration) {
        navigator.serviceWorker.registration.then(reg => {
          reg.getNotifications({ tag: 'ongoing-call' }).then(notifications => {
            notifications.forEach(n => n.close());
          });
        });
      }
    }

    // ===== STATS MONITORING =====
    function startStatsMonitoring() {
      if (statsInterval) clearInterval(statsInterval);

      statsInterval = setInterval(async () => {
        if (!pc || pc.connectionState !== 'connected') return;

        try {
          const stats = await pc.getStats();
          let packetsLost = 0;
          let packetsReceived = 0;
          let bytesReceived = 0;
          let bytesSent = 0;
          let jitter = 0;

          // Previous values for rate calculation
          const prevBytesRx = window.prevBytesRx || 0;
          const prevBytesTx = window.prevBytesTx || 0;
          const prevTime = window.prevStatsTime || Date.now();
          const now = Date.now();
          const timeDiff = (now - prevTime) / 1000;

          stats.forEach(report => {
            if (report.type === 'inbound-rtp' && report.kind === 'audio') {
              packetsLost = report.packetsLost || 0;
              packetsReceived = report.packetsReceived || 0;
              bytesReceived = report.bytesReceived || 0;
              jitter = report.jitter || 0;
            } else if (report.type === 'outbound-rtp' && report.kind === 'audio') {
              bytesSent = report.bytesSent || 0;
            }
          });

          // Calculate rates
          const rxRate = timeDiff > 0 ? ((bytesReceived - prevBytesRx) / 1024 / timeDiff).toFixed(1) : 0;
          const txRate = timeDiff > 0 ? ((bytesSent - prevBytesTx) / 1024 / timeDiff).toFixed(1) : 0;

          // Store current values
          window.prevBytesRx = bytesReceived;
          window.prevBytesTx = bytesSent;
          window.prevStatsTime = now;

          // Update UI
          const statsEl = document.getElementById('callStats');
          if (statsEl) {
            statsEl.innerHTML = `RX: ${rxRate} KB/s | TX: ${txRate} KB/s`;
            if (parseFloat(rxRate) === 0 && callSeconds > 5) {
              statsEl.style.color = 'red';
              statsEl.innerHTML += '<br>‚ö†Ô∏è No audio received';
            } else {
              statsEl.style.color = '#4ade80';
            }
          }

          const lossRate = packetsReceived > 0 ? packetsLost / packetsReceived : 0;
          const qualityEl = document.getElementById('networkQuality');

          if (lossRate < 0.01 && jitter < 0.03) {
            qualityEl.className = 'network-quality';
          } else if (lossRate < 0.05 && jitter < 0.1) {
            qualityEl.className = 'network-quality fair';
          } else {
            qualityEl.className = 'network-quality poor';
          }

          // Update debug display
          if (audioDebugEl.classList.contains('show')) {
            audioDebugEl.innerHTML = `
                  Packets: ${packetsReceived}<br>
                  Lost: ${packetsLost} (${(lossRate * 100).toFixed(1)}%)<br>
                  RX Rate: ${rxRate} KB/s<br>
                  TX Rate: ${txRate} KB/s<br>
                  Jitter: ${(jitter * 1000).toFixed(1)}ms
                `;
          }
        } catch (e) {
          log('Stats error: ' + e.message, 'warn');
        }
      }, 1000); // Update every second for smoother rate
    }

    function stopStatsMonitoring() {
      if (statsInterval) {
        clearInterval(statsInterval);
        statsInterval = null;
      }
    }

    function updateAudioDebug() {
      if (!audioDebugEl.classList.contains('show')) return;

      let info = '';
      if (pc) {
        info += `ICE: ${pc.iceConnectionState}<br>`;
        info += `Conn: ${pc.connectionState}<br>`;
      }
      if (localStream) {
        const tracks = localStream.getAudioTracks();
        info += `Local: ${tracks.length > 0 ? (tracks[0].enabled ? 'on' : 'off') : 'none'}<br>`;
      }
      if (remoteStream) {
        const tracks = remoteStream.getAudioTracks();
        info += `Remote: ${tracks.length > 0 ? tracks[0].readyState : 'none'}<br>`;
      }
      info += `Audio: ${remoteAudioEl.paused ? 'paused' : 'playing'}`;
      audioDebugEl.innerHTML = info;
    }

    // ===== ACCEPT CALL =====
    document.getElementById('acceptBtn').addEventListener('click', async () => {
      log('Accepting ' + (isVideoCall ? 'video' : 'audio') + ' call...');
      document.getElementById('incomingModal').classList.remove('show');

      callTarget = incomingData.callerId;
      callTargetName = incomingData.callerName;
      cameraOff = false;
      // NOTE: Do NOT reset iceQueue here! We need to keep the candidates that were queued while waiting
      remoteDescriptionSet = false;
      isCallConnected = false;

      initAudioContext();

      document.getElementById('callScreen').classList.add('active');

      // Setup UI based on call type
      if (isVideoCall) {
        // Video call UI
        videoContainer.classList.add('active');
        audioCallContainer.style.display = 'none';
        audioCallControls.style.display = 'none';
        document.getElementById('videoCallName').textContent = callTargetName;
        document.getElementById('videoOverlayName').textContent = callTargetName;
        document.getElementById('videoCallStatus').textContent = 'Connecting...';
        document.getElementById('videoCallTimer').textContent = '00:00';
        remoteVideoPlaceholder.classList.remove('hidden', 'connected');
      } else {
        // Audio call UI  
        videoContainer.classList.remove('active');
        audioCallContainer.style.display = 'flex';
        audioCallControls.style.display = 'flex';
        document.getElementById('callName').textContent = callTargetName;
        document.getElementById('callStatusText').textContent = 'Connecting...';
        document.getElementById('callTimer').textContent = '00:00';
        document.getElementById('callAvatar').className = 'call-avatar ringing';
      }

      try {
        log('ICE candidates in queue before setup: ' + iceQueue.length);
        await getMedia(isVideoCall);
        await createPC();

        localStream.getTracks().forEach(track => {
          log('Adding local track: ' + track.kind);
          pc.addTrack(track, localStream);
        });

        // Show local video preview for video calls
        if (isVideoCall && localStream) {
          localVideoEl.srcObject = localStream;
          localVideoWrapper.classList.remove('camera-off');
        }

        // Set remote description first (the offer)
        await pc.setRemoteDescription(new RTCSessionDescription(incomingData.offer));
        remoteDescriptionSet = true;
        log('Remote description set (offer)');

        // Process any queued ICE candidates
        processIceQueue();

        // Create and send answer
        const answer = await pc.createAnswer();
        // Apply low-bandwidth optimizations to SDP
        const modifiedSdp = sdpMunge(answer.sdp);
        await pc.setLocalDescription({ type: answer.type, sdp: modifiedSdp });
        log('Local description set (answer)');

        socket.emit('answerCall', {
          targetId: incomingData.callerId,
          answer: pc.localDescription
        });

        incomingData = null;
        startKeepAlive();

      } catch (e) {
        log('Accept error: ' + e.message, 'err');
        alert('Failed to accept call: ' + e.message);
        cleanupCall();
      }
    });

    // ===== REJECT CALL =====
    document.getElementById('rejectBtn').addEventListener('click', () => {
      log('Rejecting call');
      socket.emit('rejectCall', { targetId: incomingData.callerId });
      document.getElementById('incomingModal').classList.remove('show');
      incomingData = null;
    });

    // ===== END CALL =====
    document.getElementById('endBtn').addEventListener('click', () => {
      log('Ending call');

      if (callTarget) {
        socket.emit('endCall', { targetId: callTarget });
      }

      const duration = document.getElementById('callTimer').textContent;
      if (duration !== '00:00') {
        addSystemMessage('Call ended (' + duration + ')');
      }

      cleanupCall();
    });

    function cleanupCall() {
      log('Cleaning up call...');

      stopCallTimer();
      stopStatsMonitoring();
      stopKeepAlive();

      // Clear ICE checking timeout
      if (window.iceCheckingTimeout) {
        clearTimeout(window.iceCheckingTimeout);
        window.iceCheckingTimeout = null;
      }

      if (localStream) {
        localStream.getTracks().forEach(track => {
          track.stop();
          log('Stopped local track: ' + track.kind);
        });
        localStream = null;
      }

      if (remoteStream) {
        remoteStream.getTracks().forEach(track => track.stop());
        remoteStream = null;
      }

      if (pc) {
        pc.ontrack = null;
        pc.onicecandidate = null;
        pc.oniceconnectionstatechange = null;
        pc.onconnectionstatechange = null;
        pc.onsignalingstatechange = null;
        pc.close();
        pc = null;
      }

      // Clear audio elements
      remoteAudioEl.srcObject = null;
      remoteAudioEl.pause();

      // Clear video elements
      if (localVideoEl) {
        localVideoEl.srcObject = null;
      }
      if (remoteVideoEl) {
        remoteVideoEl.srcObject = null;
      }

      // Reset UI
      document.getElementById('callScreen').classList.remove('active');
      document.getElementById('incomingModal').classList.remove('show');
      document.getElementById('networkQuality').className = 'network-quality';
      document.getElementById('reconnectBtn').style.display = 'none';

      // Reset video UI
      videoContainer.classList.remove('active');
      audioCallContainer.style.display = 'flex';
      audioCallControls.style.display = 'flex';
      localVideoWrapper.classList.remove('camera-off');
      remoteVideoPlaceholder.classList.remove('hidden', 'connected');

      // Reset state
      callTarget = null;
      callTargetName = '';
      incomingData = null;
      iceQueue = [];
      micOff = false;
      speakerOff = false;
      speakerMode = false;
      remoteDescriptionSet = false;
      isCallConnected = false;
      isVideoCall = false;
      cameraOff = false;

      // Reset button states
      document.getElementById('micBtn').classList.remove('off');
      document.getElementById('micBtn').textContent = 'üé§';
      document.getElementById('speakerBtn').classList.remove('off', 'active');
      document.getElementById('speakerBtn').textContent = 'üì±';
      document.getElementById('speakerBtn').style.background = '#8b5cf6';
    }

    // ===== MIC TOGGLE =====
    document.getElementById('micBtn').addEventListener('click', function () {
      if (!localStream) return;

      micOff = !micOff;
      localStream.getAudioTracks().forEach(track => {
        track.enabled = !micOff;
        log('Mic track enabled: ' + track.enabled);
      });

      this.classList.toggle('off', micOff);
      this.textContent = micOff ? 'üîá' : 'üé§';
    });

    // ===== VIDEO CALL CONTROLS =====

    // Video Mic Toggle
    document.getElementById('videoMicBtn').addEventListener('click', function () {
      if (!localStream) return;

      micOff = !micOff;
      localStream.getAudioTracks().forEach(track => {
        track.enabled = !micOff;
        log('Mic track enabled: ' + track.enabled);
      });

      this.classList.toggle('off', micOff);
      this.textContent = micOff ? 'üîá' : 'üé§';
    });

    // Camera Toggle
    document.getElementById('cameraBtn').addEventListener('click', function () {
      if (!localStream) return;

      cameraOff = !cameraOff;
      localStream.getVideoTracks().forEach(track => {
        track.enabled = !cameraOff;
        log('Camera track enabled: ' + track.enabled);
      });

      this.classList.toggle('off', cameraOff);
      this.textContent = cameraOff ? 'üì∑' : 'üìπ';
      localVideoWrapper.classList.toggle('camera-off', cameraOff);
    });

    // Flip Camera (front/back)
    document.getElementById('flipCameraBtn').addEventListener('click', async function () {
      if (!localStream || !isVideoCall) return;

      log('Flipping camera...');
      facingMode = facingMode === 'user' ? 'environment' : 'user';

      // Stop current video track
      const currentVideoTrack = localStream.getVideoTracks()[0];
      if (currentVideoTrack) {
        currentVideoTrack.stop();
      }

      try {
        // Get new stream with flipped camera
        const newStream = await navigator.mediaDevices.getUserMedia({
          video: {
            facingMode: facingMode,
            width: { ideal: 1280 },
            height: { ideal: 720 }
          },
          audio: false
        });

        const newVideoTrack = newStream.getVideoTracks()[0];

        // Replace track in peer connection
        if (pc) {
          const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
          if (sender) {
            await sender.replaceTrack(newVideoTrack);
            log('Camera flipped to: ' + facingMode);
          }
        }

        // Update local stream and preview
        localStream.removeTrack(currentVideoTrack);
        localStream.addTrack(newVideoTrack);
        localVideoEl.srcObject = localStream;

      } catch (e) {
        log('Failed to flip camera: ' + e.message, 'err');
        facingMode = facingMode === 'user' ? 'environment' : 'user'; // Revert
      }
    });

    // Video End Call Button
    document.getElementById('videoEndBtn').addEventListener('click', () => {
      log('Ending video call');

      if (callTarget) {
        socket.emit('endCall', { targetId: callTarget });
      }

      const duration = document.getElementById('videoCallTimer').textContent;
      if (duration !== '00:00') {
        addSystemMessage('Video call ended (' + duration + ')');
      }

      cleanupCall();
    });

    // ===== SPEAKER/EARPIECE TOGGLE =====
    document.getElementById('speakerBtn').addEventListener('click', async function () {
      // Toggle between speaker and earpiece
      const newMode = !speakerMode;
      await setAudioOutput(newMode);
      log('Audio output switched to: ' + (newMode ? 'Speaker' : 'Earpiece'));
    });

    // Long press to mute (secondary function)
    let speakerLongPress = null;
    document.getElementById('speakerBtn').addEventListener('mousedown', function () {
      speakerLongPress = setTimeout(() => {
        speakerOff = !speakerOff;
        remoteAudioEl.muted = speakerOff;
        if (speakerOff) {
          this.textContent = 'üîá';
          this.style.background = '#666';
        } else {
          // Restore based on current mode
          this.textContent = speakerMode ? 'üîä' : 'üì±';
          this.style.background = speakerMode ? '#22c55e' : '#8b5cf6';
        }
        log('Audio muted: ' + speakerOff);
        speakerLongPress = null;
      }, 500);
    });
    document.getElementById('speakerBtn').addEventListener('mouseup', function () {
      if (speakerLongPress) {
        clearTimeout(speakerLongPress);
        speakerLongPress = null;
      }
    });
    document.getElementById('speakerBtn').addEventListener('touchstart', function () {
      speakerLongPress = setTimeout(() => {
        speakerOff = !speakerOff;
        remoteAudioEl.muted = speakerOff;
        if (speakerOff) {
          this.textContent = 'üîá';
          this.style.background = '#666';
        } else {
          this.textContent = speakerMode ? 'üîä' : 'üì±';
          this.style.background = speakerMode ? '#22c55e' : '#8b5cf6';
        }
        log('Audio muted: ' + speakerOff);
        speakerLongPress = null;
      }, 500);
    }, { passive: true });
    document.getElementById('speakerBtn').addEventListener('touchend', function () {
      if (speakerLongPress) {
        clearTimeout(speakerLongPress);
        speakerLongPress = null;
      }
    });

    // ===== TEST AUDIO BUTTON =====
    document.getElementById('testAudioBtn').addEventListener('click', () => {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const osc = ctx.createOscillator();
      const gain = ctx.createGain();

      osc.connect(gain);
      gain.connect(ctx.destination);

      osc.type = 'sine';
      osc.frequency.setValueAtTime(440, ctx.currentTime);
      osc.frequency.exponentialRampToValueAtTime(880, ctx.currentTime + 0.5);

      gain.gain.setValueAtTime(0.5, ctx.currentTime);
      gain.gain.linearRampToValueAtTime(0, ctx.currentTime + 0.5);

      osc.start();
      osc.stop(ctx.currentTime + 0.5);

      log('üîä Playing test sound...');
    });

    // ===== SDP MUNGING FOR LOW BANDWIDTH =====
    function sdpMunge(sdp) {
      log('Applying low-bandwidth optimizations to SDP...');
      const sdpLines = sdp.split('\r\n');
      const mLineIndex = sdpLines.findIndex(l => l.startsWith('m=audio'));
      if (mLineIndex === -1) {
        log('No audio m-line found in SDP, skipping optimization', 'warn');
        return sdp;
      }

      // Find opus payload type
      let opusPayload = null;
      for (let i = mLineIndex; i < sdpLines.length; i++) {
        if (sdpLines[i].startsWith('a=rtpmap:') && sdpLines[i].includes('opus/48000')) {
          opusPayload = sdpLines[i].split(':')[1].split(' ')[0];
          break;
        }
      }

      if (opusPayload) {
        log('Found Opus codec with payload type: ' + opusPayload);
        // Check if fmtp line exists
        const fmtpLineIndex = sdpLines.findIndex(l => l.startsWith(`a=fmtp:${opusPayload}`));
        if (fmtpLineIndex !== -1) {
          // Append parameters to existing line
          let fmtp = sdpLines[fmtpLineIndex];
          if (!fmtp.includes('useinbandfec=1')) fmtp += ';useinbandfec=1'; // Forward Error Correction
          if (!fmtp.includes('usedtx=1')) fmtp += ';usedtx=1';             // Discontinuous Transmission
          if (!fmtp.includes('stereo=0')) fmtp += ';stereo=0';             // Ensure Mono
          if (!fmtp.includes('maxaveragebitrate=32000')) fmtp += ';maxaveragebitrate=32000'; // 32kbps for HD Voice

          sdpLines[fmtpLineIndex] = fmtp;
          log('‚úÖ SDP optimized: FEC=on, DTX=on, Mono=on, Bitrate=32kbps');
        } else {
          // Add new fmtp line
          sdpLines.splice(mLineIndex + 1, 0, `a=fmtp:${opusPayload} useinbandfec=1;usedtx=1;stereo=0;maxaveragebitrate=32000`);
          log('‚úÖ SDP optimized: Added new fmtp line with optimizations');
        }
      } else {
        log('Opus codec not found in SDP, skipping optimization', 'warn');
      }
      return sdpLines.join('\r\n');
    }


    // ===== WAKE LOCK API - PREVENT DEVICE SLEEP =====
    async function requestWakeLock() {
      if (!('wakeLock' in navigator)) {
        log('Wake Lock API not supported');
        return;
      }

      try {
        // Release any existing lock first
        if (wakeLock) {
          await wakeLock.release();
        }

        wakeLock = await navigator.wakeLock.request('screen');
        log('Wake Lock acquired - device will stay awake');

        // Listen for wake lock release
        wakeLock.addEventListener('release', () => {
          log('Wake Lock released');
          wakeLock = null;
        });
      } catch (err) {
        log('Wake Lock error: ' + err.message, 'warn');
        wakeLock = null;
      }
    }

    function releaseWakeLock() {
      if (wakeLock) {
        wakeLock.release()
          .then(() => {
            log('Wake Lock released manually');
            wakeLock = null;
          })
          .catch(err => {
            log('Wake Lock release error: ' + err.message, 'warn');
          });
      }
    }

    // ===== VISIBILITY CHANGE - CRITICAL FOR BACKGROUND =====
    document.addEventListener('visibilitychange', () => {
      log('Visibility changed: ' + (document.hidden ? 'hidden' : 'visible'));
      isInBackground = document.hidden;

      if (document.hidden) {
        // Page going to background - keep connection alive
        if (myRoom && isConnected) {
          log('In room, starting background keep-alive...');
          startChatKeepAlive();
        }

        // Keep audio alive for calls
        if (isCallConnected) {
          log('Call active, keeping audio alive in background');
        }
      } else {
        // Page became visible - restore everything
        isInBackground = false;
        backgroundKeepAliveActive = false;

        // Stop background-specific heartbeat (regular heartbeat will continue)
        stopChatKeepAlive();

        // Verify connection is still alive
        if (myRoom && !isConnected) {
          log('Reconnecting after visibility change...', 'warn');
          socket.connect();
        } else if (myRoom && isConnected) {
          // Send immediate heartbeat to confirm connection
          socket.emit('heartbeat');
          log('Connection verified after returning from background');
        }

        // Handle audio for calls
        if (remoteAudioEl.srcObject && remoteAudioEl.paused) {
          log('Resuming audio after visibility change...');
          remoteAudioEl.play().catch(e => {
            log('Could not resume audio: ' + e.message, 'warn');
          });
        }

        if (audioContext && audioContext.state === 'suspended') {
          audioContext.resume().catch(() => { });
        }

        // Re-acquire wake lock if in room or call
        if (isCallConnected || (myRoom && isConnected)) {
          requestWakeLock();

          // Check if WebRTC connection is still healthy
          if (pc && (pc.iceConnectionState === 'disconnected' || pc.iceConnectionState === 'failed')) {
            log('WebRTC connection unhealthy after visibility change, restarting ICE', 'warn');
            pc.restartIce();
          }
        }
      }
    });

    // ===== BACKGROUND CHAT KEEP-ALIVE =====
    function startChatKeepAlive() {
      if (chatKeepAliveInterval) return; // Already running

      backgroundKeepAliveActive = true;
      log('Starting background chat keep-alive...');

      // Request wake lock to prevent device sleep
      requestWakeLock();

      // More aggressive heartbeat in background (every 5 seconds)
      chatKeepAliveInterval = setInterval(() => {
        if (!myRoom || !isConnected) {
          stopChatKeepAlive();
          return;
        }

        socket.emit('heartbeat');

        // Check if socket is still connected
        if (!socket.connected) {
          log('Socket disconnected in background, reconnecting...', 'warn');
          socket.connect();
        }

        log('Background heartbeat sent');
      }, 5000); // Every 5 seconds in background

      // Show persistent notification on Android to keep app alive
      if ('Notification' in window && Notification.permission === 'granted') {
        try {
          if (navigator.serviceWorker && navigator.serviceWorker.controller) {
            navigator.serviceWorker.controller.postMessage({
              type: 'SHOW_NOTIFICATION',
              payload: {
                title: 'üí¨ Connected to ' + myRoom,
                body: 'Chat is running in background',
                tag: 'background-chat',
                data: { roomCode: myRoom }
              }
            });
          }
        } catch (e) {
          log('Could not show background notification: ' + e.message, 'warn');
        }
      }
    }

    function stopChatKeepAlive() {
      if (chatKeepAliveInterval) {
        clearInterval(chatKeepAliveInterval);
        chatKeepAliveInterval = null;
        backgroundKeepAliveActive = false;
        log('Background chat keep-alive stopped');
      }

      // Clear background notification
      if (navigator.serviceWorker && navigator.serviceWorker.controller) {
        try {
          // Close the background notification
          navigator.serviceWorker.ready.then(registration => {
            registration.getNotifications({ tag: 'background-chat' }).then(notifications => {
              notifications.forEach(n => n.close());
            });
          });
        } catch (e) { }
      }
    }

    // Handle page freeze/resume (mobile specific - Chrome on Android)
    document.addEventListener('freeze', () => {
      log('Page frozen', 'warn');
      // Send a final heartbeat before freeze
      if (myRoom && socket.connected) {
        socket.emit('heartbeat');
      }
    });

    document.addEventListener('resume', () => {
      log('Page resumed from freeze');

      // Immediately reconnect if needed
      if (myRoom && !socket.connected) {
        log('Reconnecting after page freeze...', 'warn');
        socket.connect();
      } else if (myRoom && socket.connected) {
        socket.emit('heartbeat');
      }

      // Restore audio immediately
      if (remoteAudioEl.srcObject) {
        remoteAudioEl.play().catch(() => { });
      }

      // Resume audio context
      if (audioContext && audioContext.state === 'suspended') {
        audioContext.resume().catch(() => { });
      }

      // Re-acquire wake lock
      if (isCallConnected || (myRoom && isConnected)) {
        requestWakeLock();
      }
    });

    // ===== NOTIFICATIONS =====
    async function requestNotificationPermission() {
      if (!('Notification' in window)) return;
      if (Notification.permission !== 'granted') {
        try {
          await Notification.requestPermission();
        } catch (e) { }
      }
    }

    function showLocalNotification(title, body, data = {}) {
      if (!('Notification' in window)) return;
      if (Notification.permission !== 'granted') return;
      if (document.hasFocus()) return;

      try {
        const notification = new Notification(title, {
          body: body,
          icon: '/icon-192.png',
          tag: 'chat-notification',
          renotify: true,
          data: data
        });

        notification.onclick = () => {
          window.focus();
          notification.close();
        };

        setTimeout(() => notification.close(), 5000);
      } catch (e) { }
    }

    // ===== SERVICE WORKER =====
    if ('serviceWorker' in navigator) {
      window.addEventListener('load', async () => {
        try {
          await navigator.serviceWorker.register('/sw.js', { scope: '/' });
        } catch (e) { }
      });
    }

    // ===== AUTO-REJOIN =====
    window.addEventListener('load', () => {
      const savedRoom = localStorage.getItem('chatRoom');
      const savedName = localStorage.getItem('chatName');

      if (savedRoom && savedName) {
        document.getElementById('nameInput').value = savedName;
        document.getElementById('roomInput').value = savedRoom;
        myRoom = savedRoom;
        myName = savedName;
      }
    });

    window.addEventListener('beforeunload', () => {
      if (pc) cleanupCall();
    });
  </script>
</body>

</html>